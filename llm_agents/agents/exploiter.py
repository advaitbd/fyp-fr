# llm_agents/agents/exploiter.py

from typing import Dict, List
from openai import OpenAI
import os
import json
import re
from jsonschema import validate, ValidationError
from utils.print_utils import create_progress_spinner, print_warning

# Define JSON schema for exploit plans
EXPLOIT_SCHEMA = {
    "type": "object",
    "properties": {
        "plan": {
            "type": "object",
            "properties": {
                "setup_steps": {"type": "array", "items": {"type": "string"}},
                "execution_steps": {"type": "array", "items": {"type": "string"}},
                "validation_steps": {"type": "array", "items": {"type": "string"}},
            },
            "required": ["setup_steps", "execution_steps", "validation_steps"],
        }
    },
    "required": ["plan"],
}


class ExploiterAgent:
    def __init__(self):
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def generate_exploit_plan(self, vulnerability_info: Dict) -> Dict:
        with create_progress_spinner("Generating exploit plan") as progress:
            task = progress.add_task("Analyzing vulnerability...")

            system_prompt = """You are a smart contract security expert specialized in creating precise proof-of-concept exploits. You MUST provide your output in the exact JSON format requested, with no additional markdown formatting or explanations. Focus on creating a detailed, step-by-step exploitation plan."""
            prompt = self._construct_exploit_prompt(vulnerability_info)

            progress.update(task, description="Generating plan...")
            response = self.client.chat.completions.create(
                model="gpt-4-turbo",  # Using a more reliable model for structured JSON output
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                response_format={"type": "json_object"}  # Force JSON response
            )

            progress.update(task, description="Processing response...")
            exploit_plan = self._parse_exploit_response(response.choices[0].message.content)

            progress.update(task, completed=True)

        return {"exploit_plan": exploit_plan}

    def _construct_exploit_prompt(self, vulnerability_info: Dict) -> str:
        """
        Constructs the prompt for the LLM based on vulnerability information.

        Args:
            vulnerability_info (Dict): Information about the detected vulnerability.

        Returns:
            str: The constructed prompt.
        """
        prompt = f"""
                Analyze the following vulnerability and generate a detailed plan to demonstrate it.

                Vulnerability Type: {vulnerability_info.get('vulnerability_type', 'N/A')}
                Confidence Score: {vulnerability_info.get('confidence_score', 'N/A')}
                Reasoning: {vulnerability_info.get('reasoning', 'N/A')}
                Affected Functions: {', '.join(vulnerability_info.get('affected_functions', []))}
                Code Snippet: {vulnerability_info.get('code_snippet', 'N/A')}

                IMPORTANT: You MUST provide the exploit plan in EXACTLY this JSON format with NO additional text:

                {{
                    "plan": {{
                        "setup_steps": [
                            "Step 1: Describe what needs to be set up", 
                            "Step 2: Another setup action"
                        ],
                        "execution_steps": [
                            "Step 1: First action to perform the exploit", 
                            "Step 2: Next action in the exploit"
                        ],
                        "validation_steps": [
                            "Step 1: How to verify the exploit worked", 
                            "Step 2: Additional verification"
                        ]
                    }}
                }}

                DO NOT include any markdown formatting, explanations, or other text outside of this JSON structure.
                """
        return prompt

    def _parse_exploit_response(self, response: str) -> Dict:
        # Try to parse direct JSON first
        try:
            parsed_response = json.loads(response)
            validate(instance=parsed_response, schema=EXPLOIT_SCHEMA)
            return parsed_response.get("plan", {})
        except (json.JSONDecodeError, ValidationError):
            print_warning("Failed to parse exploit plan - trying to extract from markdown")
            
            # Try to find JSON in code blocks with multiple patterns
            json_patterns = [
                r"```json\s+(.*?)\s+```",  # JSON code block
                r"```\s+(\{.*?\})\s+```",  # Generic code block with JSON
                r"\{[\s\S]*\"plan\"[\s\S]*\}"  # Any JSON-like structure with "plan"
            ]
            
            for pattern in json_patterns:
                if match := re.search(pattern, response, re.DOTALL):
                    try:
                        # Clean up the extracted JSON string
                        json_str = match.group(1).strip()
                        # Remove any leading backticks or trailing backticks missed by the regex
                        json_str = re.sub(r'^```|```$', '', json_str)
                        # Remove excessive whitespace
                        json_str = re.sub(r'\n\s+', ' ', json_str)
                        
                        parsed_response = json.loads(json_str)
                        validate(instance=parsed_response, schema=EXPLOIT_SCHEMA)
                        return parsed_response.get("plan", {})
                    except Exception as e:
                        continue  # Try the next pattern
            
            # If no valid JSON found, try to extract the plan format manually
            try:
                # Look for section headers that might indicate steps
                setup_steps = self._extract_steps(response, ["setup", "preparation", "configure"])
                execution_steps = self._extract_steps(response, ["execution", "exploit", "attack"])
                validation_steps = self._extract_steps(response, ["validation", "verify", "confirm"])
                
                # If we found steps in at least one section, use them
                if setup_steps or execution_steps or validation_steps:
                    return {
                        "setup_steps": setup_steps,
                        "execution_steps": execution_steps,
                        "validation_steps": validation_steps
                    }
            except Exception:
                pass
                
            print_warning("Failed to parse exploit plan structure")
            return {"setup_steps": [], "execution_steps": [], "validation_steps": []}
            
    def _extract_steps(self, text: str, section_keywords: List[str]) -> List[str]:
        """Extract steps from a section in the text based on keywords."""
        steps = []
        
        # Try to find sections with the specified keywords
        pattern = r'(?i)(?:' + '|'.join(section_keywords) + r')[^\n]*?\:?\n(.*?)(?:\n\s*\n|\n\s*(?:[A-Z][a-z]+)|$)'
        match = re.search(pattern, text, re.DOTALL)
        
        if match:
            section_text = match.group(1).strip()
            # Look for numbered or bulleted list items
            step_pattern = r'(?:^|\n)\s*(?:\d+\.|\-|\*|\•)\s*(.+?)(?=$|\n\s*(?:\d+\.|\-|\*|\•)|\n\s*\n)'
            step_matches = re.finditer(step_pattern, section_text, re.DOTALL)
            
            for step_match in step_matches:
                step = step_match.group(1).strip()
                if step:
                    steps.append(step)
                    
            # If no list items found, try paragraphs
            if not steps:
                paragraphs = re.split(r'\n\s*\n', section_text)
                steps = [p.strip() for p in paragraphs if p.strip()]
        
        return steps