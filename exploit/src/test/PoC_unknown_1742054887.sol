// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "./basetest.sol";

/// @title Interface for the Uniswap Oracle (or similar)
interface IUniswapOracle {
    /// @notice Returns the number of tokens for the given ETH amount.
    /// @param ethAmount The amount of ETH.
    /// @return The equivalent token amount.
    function getTokenAmount(uint256 ethAmount) external view returns (uint256);
}

/// @title VulnerableToken contract that relies on an external oracle for determining token amount on mint
/// @notice This contract is vulnerable because it trusts the external oracle which may be manipulated.
contract VulnerableToken {
    IUniswapOracle public oracle;
    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    /// @notice Sets the oracle address.
    /// @param _oracle The address of the price oracle.
    constructor(IUniswapOracle _oracle) {
        require(address(_oracle) != address(0), "Invalid oracle address");
        oracle = _oracle;
    }

    /// @notice Mint tokens based on ETH sent and oracle pricing. Vulnerable if oracle is manipulable.
    function mint() external payable {
        require(msg.value > 0, "Must send ETH to mint");

        // Call the external oracle to get token amount corresponding to sent ETH.
        uint256 tokenAmount;
        try oracle.getTokenAmount(msg.value) returns (uint256 amount) {
            tokenAmount = amount;
        } catch {
            revert("Oracle call failed");
        }

        // In a real application, additional sanity checks should be in place.
        require(tokenAmount > 0, "Oracle returned zero tokens");

        balances[msg.sender] += tokenAmount;
        totalSupply += tokenAmount;
    }
}

/// @title A mock Uniswap Oracle that returns token amounts based on an internal price factor
/// @notice This mock oracle can be manipulated to simulate price manipulation vulnerability.
contract MockUniswapOracle is IUniswapOracle {
    uint256 public priceFactor; // How many tokens you get per 1 wei of ETH.
    address public owner;

    /// @notice Sets an initial price factor.
    constructor(uint256 _priceFactor) {
        require(_priceFactor > 0, "Price factor must be non-zero");
        priceFactor = _priceFactor;
        owner = msg.sender;
    }

    /// @notice Allows the owner to update the price factor, simulating price manipulation.
    /// @param _priceFactor The new price factor.
    function setPriceFactor(uint256 _priceFactor) external {
        require(msg.sender == owner, "Only owner can update price");
        require(_priceFactor > 0, "Price factor must be non-zero");
        priceFactor = _priceFactor;
    }

    /// @notice Returns token amount based on ETH input and current price factor.
    /// @param ethAmount The amount of ETH.
    /// @return The number of tokens.
    function getTokenAmount(
        uint256 ethAmount
    ) external view override returns (uint256) {
        return ethAmount * priceFactor;
    }
}

/// @title Foundry test contract to demonstrate an oracle manipulation vulnerability for educational purposes.
/// @notice This test demonstrates how trusting an external, manipulable oracle can lead to excessive minting.
contract YourTest is BaseTestWithBalanceLog {
    VulnerableToken public vulnerableToken;
    MockUniswapOracle public mockOracle;

    // Addresses for a normal user and an attacker for the demonstration.
    address public normalUser = address(0x123);
    address public attacker = address(0x456);

    /// @notice setUp function to deploy contracts and fund test contract.
    function setUp() public {
        // Ensure the test contract has sufficient ETH.
        vm.deal(address(this), 100 ether);

        // Deploy the mock oracle with a fair initial price factor.
        // For example, 1 wei of ETH mints 100 tokens.
        mockOracle = new MockUniswapOracle(100);

        // Deploy the vulnerable token contract using the mock oracle.
        vulnerableToken = new VulnerableToken(
            IUniswapOracle(address(mockOracle))
        );

        // Fund the normal user and attacker accounts with ETH.
        vm.deal(normalUser, 10 ether);
        vm.deal(attacker, 10 ether);
    }

    /// @notice Test function to simulate manipulation attack on the vulnerable token's mint() function.
    /// @dev This function logs balances and demonstrates the vulnerability.
    function testExploit() public balanceLog {
        // Ensure the test contract (or caller) has enough ETH.
        vm.deal(address(this), 10 ether);

        // Step 1: Normal behavior: A normal user calls mint() with a specific ETH amount.
        uint256 normalEthAmount = 1 ether;
        uint256 expectedTokensNormal = normalEthAmount * 100; // Using the fair price factor of 100.

        vm.prank(normalUser);
        // We use a low-level call to catch any errors.
        (bool successUser, bytes memory dataUser) = address(vulnerableToken)
            .call{value: normalEthAmount}(abi.encodeWithSignature("mint()"));
        require(successUser, "Normal user mint failed");
        // Optionally, decode data if needed.
        uint256 userBalance = vulnerableToken.balances(normalUser);
        require(
            userBalance == expectedTokensNormal,
            "Normal user did not receive expected token amount"
        );

        // Log normal user's balance.
        emit log_named_uint("User token balance", userBalance);

        // Step 2: Attacker manipulation: attacker modifies the oracle to return arbitrarily high token amounts.
        vm.prank(attacker);
        // Attacker becomes the owner of the mockOracle if not already.
        // For demonstration, we assume attacker can manipulate the oracle.
        // In our mock, we manually set the price factor to a high value.
        mockOracle.setPriceFactor(10000);

        uint256 attackerEthAmount = 1 ether;
        uint256 expectedTokensAttacker = attackerEthAmount * 10000; // Using the manipulated price factor.

        vm.prank(attacker);
        (bool successAttacker, bytes memory dataAttacker) = address(
            vulnerableToken
        ).call{value: attackerEthAmount}(abi.encodeWithSignature("mint()"));
        require(successAttacker, "Attacker mint failed");

        uint256 attackerBalance = vulnerableToken.balances(attacker);
        require(
            attackerBalance == expectedTokensAttacker,
            "Attacker did not receive expected token amount"
        );

        // Log attacker's balance.
        emit log_named_uint("Attacker token balance", attackerBalance);

        /*
            EDUCATIONAL COMMENTS:
            - Vulnerability: The VulnerableToken contract relies on an external oracle's response to determine the amount of tokens to mint.
              When the oracle has a function (setPriceFactor) that can be manipulated,
              an attacker can arbitrarily increase the number of tokens received for a given ETH input.
            - Prevention: Developers should not solely rely on a single external price source.
              Use techniques such as implementing sanity checks on the oracle's response, using time-weighted average prices, or integrating multiple oracle sources to mitigate risk.
        */
    }
}
