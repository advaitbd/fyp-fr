{
  "categories": {
    "reentrancy": {
      "description": "Reentrant function calls make a contract behave in an unexpected way by allowing repeated entry before previous invocations complete.",
      "examples": [
        "External calls before state changes",
        "Using .call.value() without the checks-effects-interactions pattern"
      ],
      "common_patterns": [
        "Low-level calls (call/value) followed by state changes",
        "Recursive calls to functions modifying state"
      ],
      "detection_strategy": "Check for external calls followed by state changes. Verify the use of the checks-effects-interactions pattern."
    },
    "access_control": {
      "description": "Failure to use function modifiers or use of tx.origin for authorization, leading to unauthorized access.",
      "examples": [
        "Missing function modifiers like onlyOwner",
        "Using tx.origin for authorization",
        "Public functions with privileged operations"
      ],
      "common_patterns": [
        "Sensitive functions without access modifiers",
        "Use of tx.origin in authorization checks"
      ],
      "detection_strategy": "Identify functions performing privileged operations without proper access control modifiers."
    },
    "arithmetic": {
      "description": "Integer overflows or underflows due to unbound arithmetic operations.",
      "examples": [
        "Unchecked mathematical operations",
        "Using SafeMath library incorrectly"
      ],
      "common_patterns": [
        "Arithmetic operations without overflow checks",
        "Use of deprecated SafeMath patterns"
      ],
      "detection_strategy": "Check for mathematical operations without SafeMath or Solidity 0.8+ checked math."
    },
    "unchecked_low_level_calls": {
      "description": "Low-level calls like call(), callcode(), delegatecall(), or send() fail and are not checked, leading to unexpected behavior.",
      "examples": [
        "Unchecked call()/send() return values",
        "Using delegatecall with user-controllable addresses"
      ],
      "common_patterns": [
        "Low-level calls without success checks",
        "Delegatecall to user-controlled addresses"
      ],
      "detection_strategy": "Identify call/delegatecall usage without checking return values or validating target addresses."
    },
    "denial_of_service": {
      "description": "The contract is overwhelmed with time-consuming computations, causing it to become unresponsive.",
      "examples": [
        "Unbounded loops or expensive operations",
        "External calls that can fail repeatedly"
      ],
      "common_patterns": [
        "Loops without gas limits",
        "External calls in loops"
      ],
      "detection_strategy": "Identify loops or external calls that could consume excessive gas or fail repeatedly."
    },
    "bad_randomness": {
      "description": "Malicious miners can bias the outcome of pseudo-random number generation.",
      "examples": [
        "Using block.timestamp or blockhash for randomness",
        "Relying on miner-controllable variables"
      ],
      "common_patterns": [
        "Use of block.timestamp or blockhash in randomness generation",
        "Predictable random number sources"
      ],
      "detection_strategy": "Check for reliance on block variables or other miner-controllable inputs for randomness."
    },
    "front_running": {
      "description": "Two dependent transactions that invoke the same contract are included in one block, allowing malicious actors to exploit the order of execution.",
      "examples": [
        "Transactions with predictable outcomes",
        "Unprotected state changes"
      ],
      "common_patterns": [
        "Predictable transaction ordering",
        "Lack of commit-reveal schemes"
      ],
      "detection_strategy": "Identify transactions with predictable outcomes or unprotected state changes."
    },
    "time_manipulation": {
      "description": "The timestamp of the block is manipulated by the miner, leading to unexpected behavior.",
      "examples": [
        "Using block.timestamp for critical logic",
        "Relying on block timestamps for time-sensitive operations"
      ],
      "common_patterns": [
        "Use of block.timestamp in time-sensitive logic",
        "Lack of tolerance for timestamp manipulation"
      ],
      "detection_strategy": "Check for reliance on block.timestamp in critical or time-sensitive operations."
    },
    "short_addresses": {
      "description": "The EVM accepts incorrectly padded arguments, leading to unexpected behavior.",
      "examples": [
        "Incorrectly padded arguments in function calls",
        "Maliciously crafted short addresses"
      ],
      "common_patterns": [
        "Improper input validation",
        "Use of short addresses in function calls"
      ],
      "detection_strategy": "Identify functions that do not validate input lengths or handle padding correctly."
    }
  }
}
