{
  "categories": {
    "reentrancy": {
      "description": "Reentrant function calls make a contract behave in an unexpected way by allowing repeated entry before previous invocations complete.",
      "examples": [
        "External calls before state changes",
        "Using .call.value() without the checks-effects-interactions pattern"
      ],
      "common_patterns": [
        "Low-level calls (call/value) followed by state changes",
        "Recursive calls to functions modifying state"
      ],
      "detection_strategy": "Check for external calls followed by state changes. Verify the use of the checks-effects-interactions pattern."
    },
    "access_control": {
      "description": "Failure to use function modifiers or use of tx.origin for authorization, leading to unauthorized access.",
      "examples": [
        "Missing function modifiers like onlyOwner",
        "Using tx.origin for authorization",
        "Public functions with privileged operations"
      ],
      "common_patterns": [
        "Sensitive functions without access modifiers",
        "Use of tx.origin in authorization checks"
      ],
      "detection_strategy": "Identify functions performing privileged operations without proper access control modifiers."
    },
    "arithmetic": {
      "description": "Integer overflows or underflows due to unbound arithmetic operations.",
      "examples": [
        "Unchecked mathematical operations",
        "Using SafeMath library incorrectly"
      ],
      "common_patterns": [
        "Arithmetic operations without overflow checks",
        "Use of deprecated SafeMath patterns"
      ],
      "detection_strategy": "Check for mathematical operations without SafeMath or Solidity 0.8+ checked math."
    },
    "unchecked_low_level_calls": {
      "description": "Low-level calls like call(), callcode(), delegatecall(), or send() fail and are not checked, leading to unexpected behavior.",
      "examples": [
        "Unchecked call()/send() return values",
        "Using delegatecall with user-controllable addresses"
      ],
      "common_patterns": [
        "Low-level calls without success checks",
        "Delegatecall to user-controlled addresses"
      ],
      "detection_strategy": "Identify call/delegatecall usage without checking return values or validating target addresses."
    },
    "denial_of_service": {
      "description": "The contract is overwhelmed with time-consuming computations, causing it to become unresponsive.",
      "examples": [
        "Unbounded loops or expensive operations",
        "External calls that can fail repeatedly"
      ],
      "common_patterns": [
        "Loops without gas limits",
        "External calls in loops"
      ],
      "detection_strategy": "Identify loops or external calls that could consume excessive gas or fail repeatedly."
    },
    "bad_randomness": {
      "description": "Malicious miners can bias the outcome of pseudo-random number generation.",
      "examples": [
        "Using block.timestamp or blockhash for randomness",
        "Relying on miner-controllable variables"
      ],
      "common_patterns": [
        "Use of block.timestamp or blockhash in randomness generation",
        "Predictable random number sources"
      ],
      "detection_strategy": "Check for reliance on block variables or other miner-controllable inputs for randomness."
    },
    "front_running": {
      "description": "Two dependent transactions that invoke the same contract are included in one block, allowing malicious actors to exploit the order of execution.",
      "examples": [
        "Transactions with predictable outcomes",
        "Unprotected state changes"
      ],
      "common_patterns": [
        "Predictable transaction ordering",
        "Lack of commit-reveal schemes"
      ],
      "detection_strategy": "Identify transactions with predictable outcomes or unprotected state changes."
    },
    "price_manipulation": {
      "description": "Liquidity token value/price can be manipulated to cause flashloan attacks.",
      "examples": [
        "Using AMM reserves to determine token price",
        "Manipulation of liquidity pool balances"
      ],
      "common_patterns": [
        "Usage of getPrice, getRate, totalSupply, balanceOf in liquidity calculations",
        "AMM-based calculations without external verification"
      ],
      "detection_strategy": "Identify price calculations based on AMM reserves, balanceOf, or totalSupply without external validation."
    },
    "first_deposit": {
      "description": "First depositor can break minting of shares or drain the liquidity of all users.",
      "examples": [
        "No dilution mechanism for the first deposit",
        "First depositor sets the total supply arbitrarily"
      ],
      "common_patterns": [
        "totalSupply() == 0 check without proper distribution",
        "Minting all shares to the first depositor"
      ],
      "detection_strategy": "Identify first deposit conditions without proper liquidity dilution mechanisms."
    },
    "no_slippage_limit_check": {
      "description": "No slippage limit check was performed to prevent sandwich attacks.",
      "examples": [
        "Missing minReceived checks in swaps",
        "Lack of slip limit in liquidity operations"
      ],
      "common_patterns": [
        "Unbounded price calculations in swaps",
        "Liquidity additions without limit checks"
      ],
      "detection_strategy": "Identify liquidity-related operations without slippage limit or minimum value checks."
    },
    "unauthorized_transfer": {
      "description": "The contract allows transferring tokens from an address different from the message sender without checking the approval of the address owner.",
      "examples": [
        "Direct transfer of tokens from arbitrary addresses",
        "Lack of require statement checking msg.sender approval"
      ],
      "common_patterns": [
        "Transfer function without allowance checks",
        "No verifyEIP712 or signature-based validation"
      ],
      "detection_strategy": "Identify transfer functions that do not verify allowance or approval mechanisms."
    }
  }
}
