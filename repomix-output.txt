This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-22T14:47:35.791Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
llm_agents/
  agents/
    analyzer.py
    exploiter.py
    generator.py
  agent_coordinator.py
rag/
  knowledge_base.py
  vectorstore.py
static_analysis/
  test_contracts/
    code.sol
    reentrancy.sol
    slither_demo.sol
    token.sol
  call_graph_printer.py
  parse_contract.py
  slither_detectors.py
.gitignore
main.py
requirements.txt

================================================================
Repository Files
================================================================

================
File: llm_agents/agents/analyzer.py
================
from typing import Dict, List
from openai import OpenAI
import os
from rag.vectorstore import VulnerabilityKB

class AnalyzerAgent:
    def __init__(self, kb: VulnerabilityKB):
        self.kb = kb
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def analyze(self, contract_info: Dict) -> Dict:
        # 1. Get function code and details
        functions = contract_info.get("function_details", [])

        # 2. For each function, query KB for relevant patterns
        relevant_docs = []
        for func in functions:
            # Construct function-specific query
            query = f"""
            Function name: {func['function']}
            Visibility: {func['visibility']}
            Parameters: {func['parameters']}
            Returns: {func['returns']}
            """

            # Debugging
            print("Query:", query)

            # Get relevant docs from KB
            docs = self.kb.query_knowledge_base(query)
            relevant_docs.extend(docs)

        # 3. Construct enhanced prompt with relevant docs
        prompt = self._construct_analysis_prompt(contract_info, relevant_docs)

        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": """You are a smart contract security expert analyzing potential vulnerabilities.
                When analyzing functions, pay special attention to:
                1. State variable modifications
                2. External calls
                3. Control flow patterns
                4. Access control mechanisms
                Output your analysis in a structured format with vulnerability type, confidence score, and detailed reasoning."""},
                {"role": "user", "content": prompt}
            ],
            temperature=0
        )

        return self._parse_vulnerability_response(response.choices[0].message.content)

    def _construct_analysis_prompt(self, contract_info: Dict, relevant_docs: List) -> str:
        # Start with base contract info
        prompt = "Analyze the following smart contract for potential vulnerabilities:\n\n"

        # Add function details
        functions = contract_info.get("function_details", [])
        prompt += "Functions:\n"
        for func in functions:
            prompt += f"- {func['function']} ({func['visibility']})\n"
            prompt += f"  Parameters: {func['parameters']}\n"
            prompt += f"  Returns: {func['returns']}\n\n"

        # Add call graph
        prompt += f"\nCall Graph:\n{contract_info.get('call_graph', '')}\n\n"

        # Add relevant vulnerability patterns from KB
        prompt += "\nRelevant Vulnerability Patterns:\n"
        seen_patterns = set()  # To avoid duplicates
        for doc in relevant_docs:
            pattern_key = f"{doc.metadata['name']}_{doc.metadata['type']}"
            if pattern_key not in seen_patterns:
                prompt += f"Type: {doc.metadata['type']}\n"
                prompt += f"Name: {doc.metadata['name']}\n"
                prompt += f"Content: {doc.page_content}\n\n"
                seen_patterns.add(pattern_key)

        # Add specific instructions
        prompt += "\nAnalyze the contract for these potential vulnerabilities. For each vulnerability found, provide:\n"
        prompt += "1. Vulnerability Type\n"
        prompt += "2. Confidence Score (0-1)\n"
        prompt += "3. Detailed Reasoning\n"
        prompt += "4. Affected Functions\n"

        return prompt

    def _parse_vulnerability_response(self, response: str) -> Dict:
        """Parse GPT response into structured vulnerability data"""
        try:
            # Expected format:
            # Vulnerability Type: xxx
            # Confidence: 0.x
            # Reasoning: xxx
            # Affected Functions: xxx

            lines = response.strip().split('\n')
            result = {}

            for line in lines:
                if line.startswith('Vulnerability Type:'):
                    result['vulnerability_type'] = line.split(':', 1)[1].strip()
                elif line.startswith('Confidence:'):
                    result['confidence'] = float(line.split(':', 1)[1].strip())
                elif line.startswith('Reasoning:'):
                    result['reasoning'] = line.split(':', 1)[1].strip()
                elif line.startswith('Affected Functions:'):
                    result['affected_functions'] = [
                        f.strip() for f in line.split(':', 1)[1].strip().split(',')
                    ]

            return result

        except Exception as e:
            # Fallback in case of parsing errors
            return {
                "vulnerability_type": "unknown",
                "confidence": 0.0,
                "reasoning": response,
                "affected_functions": []
            }

================
File: llm_agents/agents/exploiter.py
================
# llm_agents/agents/exploiter.py

from openai import OpenAI
from typing import Dict, List
import os
from rag.vectorstore import VulnerabilityKB

class ExploiterAgent:
    def __init__(self, kb: VulnerabilityKB):
        self.kb = kb
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def _get_exploit_template(self, vuln_type: str) -> Dict:
        """Gets exploit template from knowledge base"""
        return self.kb.get_exploit_template(vuln_type)

    def plan(self, vuln_info: Dict) -> Dict:
        # Get exploit template from KB
        template = self._get_exploit_template(vuln_info["vulnerability_type"])
        if not template:
            return {"error": "No exploit template found for vulnerability type"}

        # Get relevant docs for this vulnerability type
        docs = self.kb.query_knowledge_base(
            f"Exploit steps for {vuln_info['vulnerability_type']}"
        )

        # Construct enhanced prompt
        prompt = self._construct_exploit_prompt(vuln_info, template, docs)

        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": """You are a smart contract security expert planning vulnerability exploitation.
                For each exploit plan, provide:
                1. Detailed setup steps
                2. Precise execution steps
                3. Validation criteria
                Format your response in a clear, step-by-step manner."""},
                {"role": "user", "content": prompt}
            ],
            temperature=0
        )

        return self._parse_exploit_response(response.choices[0].message.content)

    def _construct_exploit_prompt(self, vuln_info: Dict, template: Dict, docs: List) -> str:
        prompt = f"""Plan exploitation for vulnerability type: {vuln_info['vulnerability_type']}

                Vulnerability Details:
                Confidence: {vuln_info.get('confidence', 'N/A')}
                Reasoning: {vuln_info.get('reasoning', 'N/A')}
                Affected Functions: {', '.join(vuln_info.get('affected_functions', []))}

                Template:
                Setup: {template.get('setup', 'N/A')}
                Execution: {template.get('execution', 'N/A')}
                Validation: {template.get('validation', 'N/A')}

                Additional Context:
                """

        # Add relevant docs
        for doc in docs:
            prompt += f"{doc.page_content}\n\n"

        prompt += """
                Generate a detailed exploit plan with:
                1. Setup Steps: Initial conditions and preparation needed
                2. Execution Steps: Specific actions to execute the exploit
                3. Validation Steps: How to verify the exploit worked
                """
        return prompt

    def _parse_exploit_response(self, response: str) -> Dict:
        """Parse GPT response into structured exploit plan"""
        try:
            # Expected format should have clear section markers
            sections = {
                'setup_steps': [],
                'execution_steps': [],
                'validation_steps': []
            }

            current_section = None

            for line in response.strip().split('\n'):
                line = line.strip()
                if not line:
                    continue

                if 'setup' in line.lower():
                    current_section = 'setup_steps'
                elif 'execution' in line.lower():
                    current_section = 'execution_steps'
                elif 'validation' in line.lower():
                    current_section = 'validation_steps'
                elif current_section and line.startswith(('-', '•', '*', '1.', '2.', '3.')):
                    # Remove leading markers and whitespace
                    step = line.lstrip('-•* 123456789.').strip()
                    sections[current_section].append(step)

            return sections

        except Exception as e:
            # Fallback in case of parsing errors
            return {
                'setup_steps': ['Error parsing setup steps'],
                'execution_steps': ['Error parsing execution steps'],
                'validation_steps': ['Error parsing validation steps']
            }

================
File: llm_agents/agents/generator.py
================
# llm_agents/agents/generator.py

from openai import OpenAI
from typing import Dict, List
import os
from rag.vectorstore import VulnerabilityKB

class GeneratorAgent:
    def __init__(self, kb: VulnerabilityKB):
        self.kb = kb
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def generate(self, exploit_plan: Dict) -> List[Dict]:
        # Get relevant transaction examples from KB
        docs = self.kb.query_knowledge_base(
            "Transaction sequence examples"
        )

        # Construct prompt with examples
        prompt = self._construct_generation_prompt(exploit_plan, docs)

        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": """You are a smart contract security expert generating exploit transactions.
                Generate concrete transaction sequences that follow:
                1. Proper Ethereum transaction format
                2. Correct function signatures
                3. Valid parameter encoding
                Format each transaction with from, to, value, and data fields."""},
                {"role": "user", "content": prompt}
            ],
            temperature=0
        )

        return self._parse_transaction_response(response.choices[0].message.content)

    def _construct_generation_prompt(self, exploit_plan: Dict, docs: List) -> str:
        prompt = """Generate specific transaction sequences for the following exploit plan:

Setup Steps:
"""
        for step in exploit_plan.get('setup_steps', []):
            prompt += f"- {step}\n"

        prompt += "\nExecution Steps:\n"
        for step in exploit_plan.get('execution_steps', []):
            prompt += f"- {step}\n"

        prompt += "\nValidation Steps:\n"
        for step in exploit_plan.get('validation_steps', []):
            prompt += f"- {step}\n"

        prompt += "\nRelevant Transaction Examples:\n"
        for doc in docs:
            prompt += f"{doc.page_content}\n\n"

        prompt += """
Generate a sequence of transactions in the following format for each step:
{
    "from": "0x...",    // Ethereum address
    "to": "0x...",      // Contract or EOA address
    "value": "0",       // Amount in wei
    "data": "0x..."     // Function signature + encoded parameters
}
"""
        return prompt

    def _parse_transaction_response(self, response: str) -> List[Dict]:
        """Parse GPT response into transaction sequence"""
        try:
            # Expected format should be a series of JSON-like transaction objects
            transactions = []
            current_tx = {}

            for line in response.strip().split('\n'):
                line = line.strip()
                if not line:
                    continue

                if line.startswith('{'):
                    current_tx = {}
                elif line.startswith('}'):
                    if current_tx:
                        transactions.append(current_tx.copy())
                elif ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip().strip('"')
                    value = value.strip().strip(',').strip('"')
                    current_tx[key] = value

            # Validate and clean transactions
            cleaned_transactions = []
            for tx in transactions:
                if all(k in tx for k in ['from', 'to', 'value', 'data']):
                    # Ensure addresses have 0x prefix
                    tx['from'] = tx['from'] if tx['from'].startswith('0x') else '0x' + tx['from']
                    tx['to'] = tx['to'] if tx['to'].startswith('0x') else '0x' + tx['to']
                    # Ensure data has 0x prefix
                    tx['data'] = tx['data'] if tx['data'].startswith('0x') else '0x' + tx['data']
                    cleaned_transactions.append(tx)

            return cleaned_transactions

        except Exception as e:
            # Fallback in case of parsing errors
            return [{
                "from": "0x0000000000000000000000000000000000000000",
                "to": "0x0000000000000000000000000000000000000000",
                "value": "0",
                "data": "0x"
            }]

================
File: llm_agents/agent_coordinator.py
================
# llm_agents/agent_coordinator.py
from typing import Dict, List
from .agents.analyzer import AnalyzerAgent
from .agents.exploiter import ExploiterAgent
from .agents.generator import GeneratorAgent
from rag.vectorstore import VulnerabilityKB

class AgentCoordinator:
    def __init__(self, kb: VulnerabilityKB):
        self.kb = kb
        self.analyzer = AnalyzerAgent(kb)
        self.exploiter = ExploiterAgent(kb)
        self.generator = GeneratorAgent(kb)

    def analyze_contract(self, contract_info: Dict) -> Dict:
        """
        Coordinates the analysis and exploit generation process.
        """
        # 1. Analyzer determines vulnerability type
        vuln_info = self.analyzer.analyze(contract_info)
        print("Agent A:", vuln_info)

        if not vuln_info["vulnerability_type"]:
            return {"status": "no_vulnerability_found"}

        # 2. Exploiter plans exploit strategy
        exploit_plan = self.exploiter.plan(vuln_info)

        # 3. Generator creates transaction sequence
        tx_sequence = self.generator.generate(exploit_plan)

        return {
            "vulnerability": vuln_info,
            "exploit_plan": exploit_plan,
            "transactions": tx_sequence
        }

================
File: rag/knowledge_base.py
================
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class VulnerabilityDoc:
    name: str
    description: str
    scenario: str  # From GPTScan's "Scenario" column
    property: str  # From GPTScan's "Property" column
    impact: str
    code_patterns: List[str]
    prevention: List[str]
    exploit_template: Dict[str, str]

VULNERABILITY_DOCS = [
    VulnerabilityDoc(
        name="Approval Not Cleared",
        description="""
        A vulnerability where token approvals are not properly cleared after operations,
        leaving residual approvals that could be exploited in future transactions.
        """,
        scenario="Add or check approval via require/if statements before the token transfer",
        property="There is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions",
        impact="""
        Attackers can reuse old approvals to transfer more tokens than intended by the original approver.
        """,
        code_patterns=[
            "approve() or allowance check before transfer",
            "Missing approval reset after transfer",
            "Exception handling without approval clearing"
        ],
        prevention=[
            "Reset approvals to 0 after transfer completion",
            "Clear approvals when exceptions occur",
            "Implement approve-with-expiry pattern"
        ],
        exploit_template={
            "setup": """
            1. User A approves User B to spend X tokens
            2. User B performs partial transfer of Y tokens (where Y < X)
            """,
            "execution": """
            1. User B can still transfer remaining (X-Y) tokens later
            2. Even if User A intended to revoke after first transfer
            """,
            "validation": """
            Check remaining allowance is still usable after initial transfer
            """
        }
    ),

    VulnerabilityDoc(
        name="Risky First Deposit",
        description="""
        Vulnerability in liquidity pools where the first depositor can manipulate
        the share price and exploit future depositors.
        """,
        scenario="Deposit/mint/add the liquidity pool/amount/share",
        property="Set the total share to the number of first deposit when the supply/liquidity is 0",
        impact="""
        First depositor can manipulate initial share price, affecting all future deposits
        and potentially draining value from subsequent depositors.
        """,
        code_patterns=[
            "Checking totalSupply() == 0",
            "Direct assignment of shares to first deposit amount",
            "Missing minimum deposit check"
        ],
        prevention=[
            "Implement minimum initial deposit",
            "Burn first few tokens to prevent price manipulation",
            "Use virtual reserves for initial pricing"
        ],
        exploit_template={
            "setup": """
            1. Wait for new liquidity pool deployment
            2. Prepare minimal amount of tokens
            """,
            "execution": """
            1. Make first deposit with tiny amount
            2. Receive disproportionate share of pool
            3. Wait for large deposits and extract value
            """,
            "validation": """
            Compare share price before and after large deposits
            """
        }
    ),

    VulnerabilityDoc(
        name="Price Manipulation by AMM",
        description="""
        Vulnerability where automated market maker prices can be manipulated
        through large trades or flash loans.
        """,
        scenario="Have code statements that get or calculate LP token's value/price",
        property="Based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation",
        impact="""
        Attackers can manipulate token prices to profit from arbitrage or exploit
        other contracts relying on the price feed.
        """,
        code_patterns=[
            "Using spot price for critical calculations",
            "No price manipulation checks",
            "Direct pool balance queries"
        ],
        prevention=[
            "Use time-weighted average prices (TWAP)",
            "Implement price impact limits",
            "Add slippage protection"
        ],
        exploit_template={
            "setup": """
            1. Get flash loan of large amount
            2. Identify target AMM pool
            """,
            "execution": """
            1. Execute large trade to move price
            2. Exploit price-dependent function
            3. Reverse trade and repay flash loan
            """,
            "validation": """
            Monitor price impact and profit extraction
            """
        }
    ),

    VulnerabilityDoc(
        name="Wrong Checkpoint Order",
        description="""
        A vulnerability where the order of checkpoint updates and balance changes
        is incorrect, leading to reward calculation errors.
        """,
        scenario="Have inside code statements that invoke user checkpoint",
        property="And have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward",
        impact="""
        Users can receive incorrect rewards or manipulate reward calculations by
        exploiting the wrong order of operations.
        """,
        code_patterns=[
            "Checkpoint after balance update",
            "Reward calculation before state update",
            "Missing synchronization between state changes"
        ],
        prevention=[
            "Update checkpoints before state changes",
            "Implement proper synchronization",
            "Use atomic operations where possible"
        ],
        exploit_template={
            "setup": """
            1. Identify reward-bearing token
            2. Monitor checkpoint and balance update sequence
            """,
            "execution": """
            1. Time transactions to exploit checkpoint lag
            2. Extract excess rewards
            """,
            "validation": """
            Compare actual vs expected reward amounts
            """
        }
    ),

    VulnerabilityDoc(
        name="Unauthorized Transfer",
        description="""
        A vulnerability where tokens can be transferred without proper authorization
        or allowance checks.
        """,
        scenario="Involve transfering token from an address different from message sender",
        property="And there is no check of allowance/approval from the address owner",
        impact="""
        Attackers can transfer tokens they don't own or aren't authorized to move.
        """,
        code_patterns=[
            "Missing allowance checks",
            "Incorrect sender verification",
            "Bypassed authorization logic"
        ],
        prevention=[
            "Implement proper allowance checks",
            "Verify msg.sender authorization",
            "Use OpenZeppelin's SafeERC20"
        ],
        exploit_template={
            "setup": """
            1. Identify vulnerable transfer function
            2. Target account with balance
            """,
            "execution": """
            1. Call transfer without approval
            2. Move unauthorized tokens
            """,
            "validation": """
            Verify transfers succeed without proper approval
            """
        }
    ),

    VulnerabilityDoc(
        name="Price Manipulation by Buying Tokens",
        description="""
        Vulnerability where token prices can be manipulated through buying pressure
        before important operations.
        """,
        scenario="Buy some tokens",
        property="Using Uniswap/PancakeSwap APIs",
        impact="""
        Attackers can artificially inflate token prices before operations that depend
        on token value.
        """,
        code_patterns=[
            "DEX integration calls",
            "Price queries before operations",
            "Missing price manipulation checks"
        ],
        prevention=[
            "Use TWAPs for price feeds",
            "Implement price impact limits",
            "Add cooldown periods"
        ],
        exploit_template={
            "setup": """
            1. Prepare large capital
            2. Monitor target token pool
            """,
            "execution": """
            1. Buy large amount of tokens
            2. Execute price-sensitive operation
            3. Sell tokens back
            """,
            "validation": """
            Verify profit exceeds gas and slippage costs
            """
        }
    ),

    VulnerabilityDoc(
        name="Vote Manipulation by Flashloan",
        description="""
        Vulnerability where governance votes can be manipulated using flash loans
        to temporarily acquire voting power.
        """,
        scenario="Calculate vote amount/number",
        property="And this vote amount/number is from a vote weight that might be manipulated by flashloan",
        impact="""
        Attackers can borrow large amounts of tokens to swing governance votes
        without long-term capital commitment.
        """,
        code_patterns=[
            "Vote weight calculation",
            "Snapshot mechanics",
            "Missing flashloan protection"
        ],
        prevention=[
            "Implement voting delays",
            "Check token holding duration",
            "Use delegation mechanics"
        ],
        exploit_template={
            "setup": """
            1. Identify flash loan source
            2. Calculate required voting power
            """,
            "execution": """
            1. Take flash loan
            2. Cast vote
            3. Repay flash loan
            """,
            "validation": """
            Verify vote was counted with borrowed tokens
            """
        }
    ),

    VulnerabilityDoc(
        name="Front Running",
        description="""
        Vulnerability where transactions can be front-run to gain unfair advantages
        in trading or other time-sensitive operations.
        """,
        scenario="Mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable",
        property="And this operation could be front run to benefit the account/address that can be controlled by the parameter and has no sender check in the function code",
        impact="""
        Attackers can extract value by observing pending transactions and executing
        their own transactions first.
        """,
        code_patterns=[
            "Time-sensitive operations",
            "Missing slippage checks",
            "Public value assignments"
        ],
        prevention=[
            "Implement commit-reveal schemes",
            "Add minimum wait times",
            "Use private mempool"
        ],
        exploit_template={
            "setup": """
            1. Monitor mempool
            2. Prepare front-running bot
            """,
            "execution": """
            1. Detect profitable transaction
            2. Submit higher gas transaction
            3. Execute before target
            """,
            "validation": """
            Compare execution order and profit
            """
        }
    ),

    VulnerabilityDoc(
        name="Wrong Interest Rate Order",
        description="""
        Vulnerability where interest rate updates are performed in incorrect order,
        leading to calculation errors.
        """,
        scenario="Have inside code statements that update/accrue interest/exchange rate",
        property="And have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward",
        impact="""
        Users can receive incorrect interest calculations or manipulate rates for profit.
        """,
        code_patterns=[
            "Interest rate updates",
            "Balance calculations",
            "Order-dependent operations"
        ],
        prevention=[
            "Follow rate-before-balance pattern",
            "Use atomic rate updates",
            "Implement rate checkpoints"
        ],
        exploit_template={
            "setup": """
            1. Monitor interest rate changes
            2. Identify calculation sequence
            """,
            "execution": """
            1. Time transaction before rate update
            2. Exploit calculation order
            """,
            "validation": """
            Compare actual vs expected interest
            """
        }
    ),

    VulnerabilityDoc(
        name="Slippage",
        description="""
        Vulnerability where trades can experience unexpected price slippage due to
        missing or inadequate slippage protection.
        """,
        scenario="Involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries",
        property="But this operation could be attacked by Slippage/Sandwich Attack due to no slip limit/minimum value check",
        impact="""
        Users can experience significant losses due to price movement between
        transaction submission and execution.
        """,
        code_patterns=[
            "DEX integration",
            "Missing slippage checks",
            "Price-sensitive operations"
        ],
        prevention=[
            "Add slippage parameters",
            "Implement price bounds",
            "Use price oracles"
        ],
        exploit_template={
            "setup": """
            1. Monitor large pending swaps
            2. Calculate profitable slippage
            """,
            "execution": """
            1. Front-run with buy
            2. Let victim transaction execute
            3. Back-run with sell
            """,
            "validation": """
            Verify extracted value from slippage
            """
        }
    )
]

================
File: rag/vectorstore.py
================
import os
from typing import List, Dict
from langchain_community.vectorstores import FAISS
from langchain_openai import OpenAIEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain.docstore.document import Document
from .knowledge_base import VULNERABILITY_DOCS

class VulnerabilityKB:
    def __init__(self):
        # Initialize embeddings with OpenAI API
        self.embeddings = OpenAIEmbeddings(
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )

        # Text splitter for chunking docs
        self.text_splitter = CharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )

        # Create vector store
        self.vectorstore = self._initialize_vectorstore()

    def _initialize_vectorstore(self):
        """Initialize FAISS vector store with vulnerability docs"""
        # Convert vulnerability docs to text chunks
        docs = []
        for vuln_doc in VULNERABILITY_DOCS:
            # Create document for each section
            docs.extend([
                Document(
                    page_content=vuln_doc.description,
                    metadata={"type": "description", "name": vuln_doc.name}
                ),
                Document(
                    page_content=vuln_doc.scenario,
                    metadata={"type": "scenario", "name": vuln_doc.name}
                ),
                Document(
                    page_content="\n".join(vuln_doc.code_patterns),
                    metadata={"type": "patterns", "name": vuln_doc.name}
                ),
                Document(
                    page_content="\n".join(vuln_doc.prevention),
                    metadata={"type": "prevention", "name": vuln_doc.name}
                ),
                Document(
                    page_content=str(vuln_doc.exploit_template),
                    metadata={"type": "exploit", "name": vuln_doc.name}
                )
            ])

        # Split into chunks
        chunks = self.text_splitter.split_documents(docs)

        # Create vector store
        return FAISS.from_documents(chunks, self.embeddings)

    def query_knowledge_base(self, query: str, k: int = 3) -> List[Document]:
        """Enhanced query with better pattern matching"""
        # Add vulnerability pattern context to query
        enhanced_query = f"""
        Vulnerability context: {query}
        Common patterns:
        - State variable modifications
        - External calls
        - Access control
        - Price calculations
        - Token operations
        """

        return self.vectorstore.similarity_search(enhanced_query, k=k)

    def get_exploit_template(self, vuln_name: str) -> Dict[str, str]:
        """Get exploit template for specific vulnerability"""
        for doc in VULNERABILITY_DOCS:
            if doc.name.lower() == vuln_name.lower():
                return doc.exploit_template
        return None

# Usage example
if __name__ == "__main__":
    kb = VulnerabilityKB()

    # Query for reentrancy patterns
    results = kb.query_knowledge_base(
        "What are code patterns indicating reentrancy?"
    )

    for doc in results:
        print(f"Document type: {doc.metadata['type']}")
        print(f"Content: {doc.page_content}\n")

    # Get exploit template
    template = kb.get_exploit_template("reentrancy")
    print("Exploit template:", template)

================
File: static_analysis/test_contracts/code.sol
================
/**
 *Submitted for verification at BscScan.com on 2021-05-02
 */

/**
 *Submitted for verification at BscScan.com on 2020-09-27
 */

// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.8;
pragma experimental ABIEncoderV2;

interface iBEP20 {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address, uint256) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function burnFrom(address, uint256) external;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

interface iWBNB {
    function withdraw(uint256) external;
}

interface iBASE {
    function secondsPerEra() external view returns (uint256);

    function DAO() external view returns (iDAO);
}

interface iUTILS {
    function calcPart(uint bp, uint total) external pure returns (uint part);

    function calcShare(
        uint part,
        uint total,
        uint amount
    ) external pure returns (uint share);

    function calcLiquidityShare(
        uint units,
        address token,
        address pool,
        address member
    ) external pure returns (uint share);

    function calcSwapOutput(
        uint x,
        uint X,
        uint Y
    ) external pure returns (uint output);

    function calcSwapFee(
        uint x,
        uint X,
        uint Y
    ) external pure returns (uint output);

    function calcLiquidityUnits(
        uint b,
        uint B,
        uint t,
        uint T,
        uint P
    ) external pure returns (uint units);

    function getPoolShare(
        address token,
        uint units
    ) external view returns (uint baseAmount, uint tokenAmount);

    function getPoolShareAssym(
        address token,
        uint units,
        bool toBase
    ) external view returns (uint baseAmount, uint tokenAmount, uint outputAmt);

    function calcValueInBase(
        address token,
        uint amount
    ) external view returns (uint value);

    function calcValueInToken(
        address token,
        uint amount
    ) external view returns (uint value);

    function calcValueInBaseWithPool(
        address pool,
        uint amount
    ) external view returns (uint value);
}

interface iDAO {
    function ROUTER() external view returns (address);

    function UTILS() external view returns (iUTILS);
}

// SafeMath
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
}

contract Pool is iBEP20 {
    using SafeMath for uint256;

    address public BASE;
    address public TOKEN;

    uint256 public one = 10 ** 18;

    // ERC-20 Parameters
    string _name;
    string _symbol;
    uint256 public override decimals;
    uint256 public override totalSupply;
    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint public genesis;
    uint public baseAmount;
    uint public tokenAmount;
    uint public baseAmountPooled;
    uint public tokenAmountPooled;
    uint public fees;
    uint public volume;
    uint public txCount;

    event AddLiquidity(
        address member,
        uint inputBase,
        uint inputToken,
        uint unitsIssued
    );
    event RemoveLiquidity(
        address member,
        uint outputBase,
        uint outputToken,
        uint unitsClaimed
    );
    event Swapped(
        address tokenFrom,
        address tokenTo,
        uint inputAmount,
        uint outputAmount,
        uint fee,
        address recipient
    );

    function _DAO() internal view returns (iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor(address _base, address _token) public payable {
        BASE = _base;
        TOKEN = _token;

        string memory poolName = "SpartanPoolV1-";
        string memory poolSymbol = "SPT1-";
        _name = string(abi.encodePacked(poolName, iBEP20(_token).name()));
        _symbol = string(abi.encodePacked(poolSymbol, iBEP20(_token).symbol()));

        decimals = 18;
        genesis = now;
    }

    //========================================iBEP20=========================================//
    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(
        address owner,
        address spender
    ) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    // iBEP20 Transfer function
    function transfer(
        address to,
        uint256 value
    ) public override returns (bool success) {
        _transfer(msg.sender, to, value);
        return true;
    }

    // iBEP20 Approve function
    function approve(
        address spender,
        uint256 amount
    ) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    // iBEP20 TransferFrom function
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) public override returns (bool success) {
        require(value <= _allowances[from][msg.sender], "AllowanceErr");
        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(
            value
        );
        _transfer(from, to, value);
        return true;
    }

    // Internal transfer function
    function _transfer(address _from, address _to, uint256 _value) private {
        require(_balances[_from] >= _value, "BalanceErr");
        require(_balances[_to] + _value >= _balances[_to], "BalanceErr");
        _balances[_from] -= _value;
        _balances[_to] += _value;
        emit Transfer(_from, _to, _value);
    }

    // Contract can mint
    function _mint(address account, uint256 amount) internal {
        totalSupply = totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    // Burn supply
    function burn(uint256 amount) public virtual {
        _burn(msg.sender, amount);
    }

    function burnFrom(address from, uint256 value) public virtual override {
        require(value <= _allowances[from][msg.sender], "AllowanceErr");
        _allowances[from][msg.sender] -= value;
        _burn(from, value);
    }

    function _burn(address account, uint256 amount) internal virtual {
        _balances[account] = _balances[account].sub(amount, "BalanceErr");
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    //==================================================================================//
    // Asset Movement Functions

    // TransferTo function
    function transferTo(
        address recipient,
        uint256 amount
    ) public returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Sync internal balances to actual
    function sync() public {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    // Add liquidity for self
    function addLiquidity() public returns (uint liquidityUnits) {
        liquidityUnits = addLiquidityForMember(msg.sender);
        return liquidityUnits;
    }

    // Add liquidity for a member
    function addLiquidityForMember(
        address member
    ) public returns (uint liquidityUnits) {
        uint256 _actualInputBase = _getAddedBaseAmount();
        uint256 _actualInputToken = _getAddedTokenAmount();
        liquidityUnits = _DAO().UTILS().calcLiquidityUnits(
            _actualInputBase,
            baseAmount,
            _actualInputToken,
            tokenAmount,
            totalSupply
        );
        _incrementPoolBalances(_actualInputBase, _actualInputToken);
        _mint(member, liquidityUnits);
        emit AddLiquidity(
            member,
            _actualInputBase,
            _actualInputToken,
            liquidityUnits
        );
        return liquidityUnits;
    }

    // Remove Liquidity
    function removeLiquidity()
        public
        returns (uint outputBase, uint outputToken)
    {
        return removeLiquidityForMember(msg.sender);
    }

    // Remove Liquidity for a member
    function removeLiquidityForMember(
        address member
    ) public returns (uint outputBase, uint outputToken) {
        uint units = balanceOf(address(this));
        outputBase = _DAO().UTILS().calcLiquidityShare(
            units,
            BASE,
            address(this),
            member
        );
        outputToken = _DAO().UTILS().calcLiquidityShare(
            units,
            TOKEN,
            address(this),
            member
        );
        _decrementPoolBalances(outputBase, outputToken);
        _burn(address(this), units);
        iBEP20(BASE).transfer(member, outputBase);
        iBEP20(TOKEN).transfer(member, outputToken);
        emit RemoveLiquidity(member, outputBase, outputToken, units);
        return (outputBase, outputToken);
    }

    function swap(address token) public returns (uint outputAmount, uint fee) {
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    function swapTo(
        address token,
        address member
    ) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), "Must be BASE or TOKEN");
        address _fromToken;
        uint _amount;
        if (token == BASE) {
            _fromToken = TOKEN;
            _amount = _getAddedTokenAmount();
            (outputAmount, fee) = _swapTokenToBase(_amount);
        } else {
            _fromToken = BASE;
            _amount = _getAddedBaseAmount();
            (outputAmount, fee) = _swapBaseToToken(_amount);
        }
        emit Swapped(_fromToken, token, _amount, outputAmount, fee, member);
        iBEP20(token).transfer(member, outputAmount);
        return (outputAmount, fee);
    }

    function _getAddedBaseAmount() internal view returns (uint256 _actual) {
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this));
        if (_baseBalance > baseAmount) {
            _actual = _baseBalance.sub(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function _getAddedTokenAmount() internal view returns (uint256 _actual) {
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this));
        if (_tokenBalance > tokenAmount) {
            _actual = _tokenBalance.sub(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function _swapBaseToToken(
        uint256 _x
    ) internal returns (uint256 _y, uint256 _fee) {
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y = _DAO().UTILS().calcSwapOutput(_x, _X, _Y);
        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);
        _setPoolAmounts(_X.add(_x), _Y.sub(_y));
        _addPoolMetrics(_y + _fee, _fee, false);
        return (_y, _fee);
    }

    function _swapTokenToBase(
        uint256 _x
    ) internal returns (uint256 _y, uint256 _fee) {
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y = _DAO().UTILS().calcSwapOutput(_x, _X, _Y);
        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);
        _setPoolAmounts(_Y.sub(_y), _X.add(_x));
        _addPoolMetrics(_y + _fee, _fee, true);
        return (_y, _fee);
    }

    //==================================================================================//
    // Data Model

    // Increment internal balances
    function _incrementPoolBalances(
        uint _baseAmount,
        uint _tokenAmount
    ) internal {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
        baseAmountPooled += _baseAmount;
        tokenAmountPooled += _tokenAmount;
    }

    function _setPoolAmounts(
        uint256 _baseAmount,
        uint256 _tokenAmount
    ) internal {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount;
    }

    // Decrement internal balances
    function _decrementPoolBalances(
        uint _baseAmount,
        uint _tokenAmount
    ) internal {
        uint _removedBase = _DAO().UTILS().calcShare(
            _baseAmount,
            baseAmount,
            baseAmountPooled
        );
        uint _removedToken = _DAO().UTILS().calcShare(
            _tokenAmount,
            tokenAmount,
            tokenAmountPooled
        );
        baseAmountPooled = baseAmountPooled.sub(_removedBase);
        tokenAmountPooled = tokenAmountPooled.sub(_removedToken);
        baseAmount = baseAmount.sub(_baseAmount);
        tokenAmount = tokenAmount.sub(_tokenAmount);
    }

    function _addPoolMetrics(
        uint256 _volume,
        uint256 _fee,
        bool _toBase
    ) internal {
        if (_toBase) {
            volume += _volume;
            fees += _fee;
        } else {
            volume += _DAO().UTILS().calcValueInBaseWithPool(
                address(this),
                _volume
            );
            fees += _DAO().UTILS().calcValueInBaseWithPool(address(this), _fee);
        }
        txCount += 1;
    }
}

contract Router {
    using SafeMath for uint256;

    address public BASE;
    address public WBNB;
    address public DEPLOYER;

    uint public totalPooled;
    uint public totalVolume;
    uint public totalFees;
    uint public removeLiquidityTx;
    uint public addLiquidityTx;
    uint public swapTx;

    address[] public arrayTokens;
    mapping(address => address) private mapToken_Pool;
    mapping(address => bool) public isPool;

    event NewPool(address token, address pool, uint genesis);
    event AddLiquidity(
        address member,
        uint inputBase,
        uint inputToken,
        uint unitsIssued
    );
    event RemoveLiquidity(
        address member,
        uint outputBase,
        uint outputToken,
        uint unitsClaimed
    );
    event Swapped(
        address tokenFrom,
        address tokenTo,
        uint inputAmount,
        uint transferAmount,
        uint outputAmount,
        uint fee,
        address recipient
    );

    // Only Deployer can execute
    modifier onlyDeployer() {
        require(msg.sender == DEPLOYER, "DeployerErr");
        _;
    }

    constructor() public payable {
        BASE = 0xE4Ae305ebE1AbE663f261Bc00534067C80ad677C;
        WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
        DEPLOYER = msg.sender;
    }

    function _DAO() internal view returns (iDAO) {
        return iBASE(BASE).DAO();
    }

    receive() external payable {}

    // In case of new router can migrate metrics
    function migrateRouterData(address payable oldRouter) public onlyDeployer {
        totalPooled = Router(oldRouter).totalPooled();
        totalVolume = Router(oldRouter).totalVolume();
        totalFees = Router(oldRouter).totalFees();
        removeLiquidityTx = Router(oldRouter).removeLiquidityTx();
        addLiquidityTx = Router(oldRouter).addLiquidityTx();
        swapTx = Router(oldRouter).swapTx();
    }

    function migrateTokenData(address payable oldRouter) public onlyDeployer {
        uint256 tokenCount = Router(oldRouter).tokenCount();
        for (uint256 i = 0; i < tokenCount; i++) {
            address token = Router(oldRouter).getToken(i);
            address pool = Router(oldRouter).getPool(token);
            isPool[pool] = true;
            arrayTokens.push(token);
            mapToken_Pool[token] = pool;
        }
    }

    function purgeDeployer() public onlyDeployer {
        DEPLOYER = address(0);
    }

    function createPool(
        uint256 inputBase,
        uint256 inputToken,
        address token
    ) public payable returns (address pool) {
        require(getPool(token) == address(0), "CreateErr");
        require(token != BASE, "Must not be Base");
        require((inputToken > 0 && inputBase > 0), "Must get tokens for both");
        Pool newPool;
        address _token = token;
        if (token == address(0)) {
            _token = WBNB;
        } // Handle BNB
        newPool = new Pool(BASE, _token);
        pool = address(newPool);
        mapToken_Pool[_token] = pool;
        uint256 _actualInputBase = _handleTransferIn(BASE, inputBase, pool);
        _handleTransferIn(token, inputToken, pool);
        arrayTokens.push(_token);
        isPool[pool] = true;
        totalPooled += _actualInputBase;
        addLiquidityTx += 1;
        Pool(pool).addLiquidityForMember(msg.sender);
        emit NewPool(token, pool, now);
        return pool;
    }

    //==================================================================================//
    // Add/Remove Liquidity functions

    // Add liquidity for self
    function addLiquidity(
        uint inputBase,
        uint inputToken,
        address token
    ) public payable returns (uint units) {
        units = addLiquidityForMember(inputBase, inputToken, token, msg.sender);
        return units;
    }

    // Add liquidity for member
    function addLiquidityForMember(
        uint inputBase,
        uint inputToken,
        address token,
        address member
    ) public payable returns (uint units) {
        address pool = getPool(token);
        uint256 _actualInputBase = _handleTransferIn(BASE, inputBase, pool);
        _handleTransferIn(token, inputToken, pool);
        totalPooled += _actualInputBase;
        addLiquidityTx += 1;
        units = Pool(pool).addLiquidityForMember(member);
        return units;
    }

    // Remove % for self
    function removeLiquidity(
        uint basisPoints,
        address token
    ) public returns (uint outputBase, uint outputToken) {
        require((basisPoints > 0 && basisPoints <= 10000), "InputErr");
        uint _units = _DAO().UTILS().calcPart(
            basisPoints,
            iBEP20(getPool(token)).balanceOf(msg.sender)
        );
        return removeLiquidityExact(_units, token);
    }

    // Remove an exact qty of units
    function removeLiquidityExact(
        uint units,
        address token
    ) public returns (uint outputBase, uint outputToken) {
        address _pool = getPool(token);
        address _member = msg.sender;
        Pool(_pool).transferTo(_pool, units);
        (outputBase, outputToken) = Pool(_pool).removeLiquidityForMember(
            _member
        );
        totalPooled = totalPooled.sub(outputBase);
        removeLiquidityTx += 1;
        return (outputBase, outputToken);
    }

    // Remove % Asymmetrically
    function removeLiquidityAndSwap(
        uint basisPoints,
        bool toBase,
        address token
    ) public returns (uint outputAmount) {
        uint _units = _DAO().UTILS().calcPart(
            basisPoints,
            iBEP20(getPool(token)).balanceOf(msg.sender)
        );
        outputAmount = removeLiquidityExactAndSwap(_units, toBase, token);
        return outputAmount;
    }

    // Remove Exact Asymmetrically
    function removeLiquidityExactAndSwap(
        uint units,
        bool toBase,
        address token
    ) public returns (uint outputAmount) {
        address _pool = getPool(token);
        require(units < iBEP20(_pool).totalSupply(), "InputErr");
        Pool(_pool).transferTo(_pool, units);
        (uint _outputBase, uint _outputToken) = Pool(_pool).removeLiquidity();
        totalPooled = totalPooled.sub(_outputBase);
        removeLiquidityTx += 1;
        if (toBase) {
            // sell to BASE
            iBEP20(token).transfer(_pool, _outputToken);
            (uint _baseBought, uint _fee) = Pool(_pool).swap(token);
            totalFees += _fee;
            outputAmount = _baseBought.add(_outputBase);
            _handleTransferOut(BASE, outputAmount, msg.sender);
        } else {
            // buy to TOKEN
            iBEP20(BASE).transfer(_pool, _outputToken);
            (uint _tokenBought, uint _fee) = Pool(_pool).swap(BASE);
            totalFees += _DAO().UTILS().calcValueInBase(token, _fee);
            outputAmount = _tokenBought.add(_outputToken);
            _handleTransferOut(token, outputAmount, msg.sender);
        }
        return outputAmount;
    }

    //==================================================================================//
    // Swapping Functions

    function buy(
        uint256 amount,
        address token
    ) public returns (uint256 outputAmount, uint256 fee) {
        return buyTo(amount, token, msg.sender);
    }

    function buyTo(
        uint amount,
        address token,
        address member
    ) public returns (uint outputAmount, uint fee) {
        require(token != BASE, "TokenTypeErr");
        if (token == address(0)) {
            token = WBNB;
        } // Handle BNB
        address _pool = getPool(token);
        uint _actualAmount = _handleTransferIn(BASE, amount, _pool);
        (outputAmount, fee) = Pool(_pool).swapTo(token, member);
        totalPooled += _actualAmount;
        totalVolume += _actualAmount;
        totalFees += _DAO().UTILS().calcValueInBase(token, fee);
        swapTx += 1;
        return (outputAmount, fee);
    }

    function sell(
        uint amount,
        address token
    ) public payable returns (uint outputAmount, uint fee) {
        return sellTo(amount, token, msg.sender);
    }

    function sellTo(
        uint amount,
        address token,
        address member
    ) public payable returns (uint outputAmount, uint fee) {
        require(token != BASE, "TokenTypeErr");
        address _pool = getPool(token);
        _handleTransferIn(token, amount, _pool);
        (outputAmount, fee) = Pool(_pool).swapTo(BASE, member);
        totalPooled = totalPooled.sub(outputAmount);
        totalVolume += outputAmount;
        totalFees += fee;
        swapTx += 1;
        return (outputAmount, fee);
    }

    function swap(
        uint256 inputAmount,
        address fromToken,
        address toToken
    ) public payable returns (uint256 outputAmount, uint256 fee) {
        return swapTo(inputAmount, fromToken, toToken, msg.sender);
    }

    function swapTo(
        uint256 inputAmount,
        address fromToken,
        address toToken,
        address member
    ) public payable returns (uint256 outputAmount, uint256 fee) {
        require(fromToken != toToken, "TokenTypeErr");
        uint256 _transferAmount = 0;
        if (fromToken == BASE) {
            (outputAmount, fee) = buyTo(inputAmount, toToken, member);
        } else if (toToken == BASE) {
            (outputAmount, fee) = sellTo(inputAmount, fromToken, member);
        } else {
            address _poolTo = getPool(toToken);
            (uint256 _yy, uint256 _feey) = sellTo(
                inputAmount,
                fromToken,
                _poolTo
            );
            totalVolume += _yy;
            totalFees += _feey;
            if (toToken == address(0)) {
                toToken = WBNB;
            } // Handle BNB
            (uint _zz, uint _feez) = Pool(_poolTo).swapTo(toToken, member);
            totalFees += _DAO().UTILS().calcValueInBase(toToken, _feez);
            _transferAmount = _yy;
            outputAmount = _zz;
            fee = _feez + _DAO().UTILS().calcValueInToken(toToken, _feey);
        }
        emit Swapped(
            fromToken,
            toToken,
            inputAmount,
            _transferAmount,
            outputAmount,
            fee,
            member
        );
        return (outputAmount, fee);
    }

    //==================================================================================//
    // Token Transfer Functions

    function _handleTransferIn(
        address _token,
        uint256 _amount,
        address _pool
    ) internal returns (uint256 actual) {
        if (_amount > 0) {
            if (_token == address(0)) {
                // If BNB, then send to WBNB contract, then forward WBNB to pool
                require((_amount == msg.value), "InputErr");
                payable(WBNB).call{value: _amount}("");
                iBEP20(WBNB).transfer(_pool, _amount);
                actual = _amount;
            } else {
                uint startBal = iBEP20(_token).balanceOf(_pool);
                iBEP20(_token).transferFrom(msg.sender, _pool, _amount);
                actual = iBEP20(_token).balanceOf(_pool).sub(startBal);
            }
        }
    }

    function _handleTransferOut(
        address _token,
        uint256 _amount,
        address _recipient
    ) internal {
        if (_amount > 0) {
            if (_token == address(0)) {
                // If BNB, then withdraw to BNB, then forward BNB to recipient
                iWBNB(WBNB).withdraw(_amount);
                payable(_recipient).call{value: _amount}("");
            } else {
                iBEP20(_token).transfer(_recipient, _amount);
            }
        }
    }

    //======================================HELPERS========================================//
    // Helper Functions

    function getPool(address token) public view returns (address pool) {
        if (token == address(0)) {
            pool = mapToken_Pool[WBNB]; // Handle BNB
        } else {
            pool = mapToken_Pool[token]; // Handle normal token
        }
        return pool;
    }

    function tokenCount() public view returns (uint256) {
        return arrayTokens.length;
    }

    function getToken(uint256 i) public view returns (address) {
        return arrayTokens[i];
    }
}

================
File: static_analysis/test_contracts/reentrancy.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyVulnerable {
    mapping(address => uint256) public balances;

    // Deposit function allows users to send Ether to the contract
    function deposit() external payable {
        require(msg.value > 0, "Must send some Ether");
        balances[msg.sender] += msg.value;
    }

    // Withdraw function contains a reentrancy vulnerability
    function withdraw(uint256 _amount) external {
        require(balances[msg.sender] >= _amount, "Insufficient balance");

        // Transfer Ether to the caller (external call before state update)
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");

        // Update the user's balance (state update happens after the external call)
        balances[msg.sender] -= _amount;
    }

    // Helper function to check the contract balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

================
File: static_analysis/test_contracts/slither_demo.sol
================
pragma solidity ^0.8.0;

contract SlitherDemo {
    address public king;
    uint public balance;

    function claimThrone() external payable {
        require(msg.value > balance, "Need to pay more to become the king");
        (bool sent, ) = king.call{value: balance}("");
        require(sent, "Failed to send Ether");
        balance = msg.value;
        king = msg.sender;
    }
}

================
File: static_analysis/test_contracts/token.sol
================
pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) balances;

    constructor() {
        balances[msg.sender] = 1000;
    }

    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Not enough");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
}

================
File: static_analysis/call_graph_printer.py
================
"""
    Module printing the call graph

    The call graph shows for each function,
    what are the contracts/functions called.
    The output is a dot file named filename.dot
"""
from collections import defaultdict
from typing import Optional, Union, Dict, Set, Tuple, Sequence

from slither.core.declarations import Contract, FunctionContract
from slither.core.declarations.function import Function
from slither.core.declarations.solidity_variables import SolidityFunction
from slither.core.variables.variable import Variable
from slither.printers.abstract_printer import AbstractPrinter
from slither.utils.output import Output


def _contract_subgraph(contract: Contract) -> str:
    return f"cluster_{contract.id}_{contract.name}"


# return unique id for contract function to use as node name
def _function_node(contract: Contract, function: Union[Function, Variable]) -> str:
    return f"{contract.id}_{function.name}"


# return unique id for solidity function to use as node name
def _solidity_function_node(solidity_function: SolidityFunction) -> str:
    return f"{solidity_function.name}"


# return dot language string to add graph edge
def _edge(from_node: str, to_node: str) -> str:
    return f'"{from_node}" -> "{to_node}"'


# return dot language string to add graph node (with optional label)
def _node(node: str, label: Optional[str] = None) -> str:
    return " ".join(
        (
            f'"{node}"',
            f'[label="{label}"]' if label is not None else "",
        )
    )


# pylint: disable=too-many-arguments
def _process_internal_call(
    contract: Contract,
    function: Function,
    internal_call: Union[Function, SolidityFunction],
    contract_calls: Dict[Contract, Set[str]],
    solidity_functions: Set[str],
    solidity_calls: Set[str],
) -> None:
    if isinstance(internal_call, (Function)):
        contract_calls[contract].add(
            _edge(
                _function_node(contract, function),
                _function_node(contract, internal_call),
            )
        )
    elif isinstance(internal_call, (SolidityFunction)):
        solidity_functions.add(
            _node(_solidity_function_node(internal_call)),
        )
        solidity_calls.add(
            _edge(
                _function_node(contract, function),
                _solidity_function_node(internal_call),
            )
        )


def _render_external_calls(external_calls: Set[str]) -> str:
    return "\n".join(external_calls)


def _render_internal_calls(
    contract: Contract,
    contract_functions: Dict[Contract, Set[str]],
    contract_calls: Dict[Contract, Set[str]],
) -> str:
    lines = []

    lines.append(f"subgraph {_contract_subgraph(contract)} {{")
    lines.append(f'label = "{contract.name}"')

    lines.extend(contract_functions[contract])
    lines.extend(contract_calls[contract])

    lines.append("}")

    return "\n".join(lines)


def _render_solidity_calls(solidity_functions: Set[str], solidity_calls: Set[str]) -> str:
    lines = []

    lines.append("subgraph cluster_solidity {")
    lines.append('label = "[Solidity]"')

    lines.extend(solidity_functions)
    lines.extend(solidity_calls)

    lines.append("}")

    return "\n".join(lines)


def _process_external_call(
    contract: Contract,
    function: Function,
    external_call: Tuple[Contract, Union[Function, Variable]],
    contract_functions: Dict[Contract, Set[str]],
    external_calls: Set[str],
    all_contracts: Set[Contract],
) -> None:
    external_contract, external_function = external_call

    if not external_contract in all_contracts:
        return

    # add variable as node to respective contract
    if isinstance(external_function, (Variable)):
        contract_functions[external_contract].add(
            _node(
                _function_node(external_contract, external_function),
                external_function.name,
            )
        )

    external_calls.add(
        _edge(
            _function_node(contract, function),
            _function_node(external_contract, external_function),
        )
    )


# pylint: disable=too-many-arguments
def _process_function(
    contract: Contract,
    function: Function,
    contract_functions: Dict[Contract, Set[str]],
    contract_calls: Dict[Contract, Set[str]],
    solidity_functions: Set[str],
    solidity_calls: Set[str],
    external_calls: Set[str],
    all_contracts: Set[Contract],
) -> None:
    contract_functions[contract].add(
        _node(_function_node(contract, function), function.name),
    )

    for internal_call in function.internal_calls:
        _process_internal_call(
            contract,
            function,
            internal_call,
            contract_calls,
            solidity_functions,
            solidity_calls,
        )
    for external_call in function.high_level_calls:
        _process_external_call(
            contract,
            function,
            external_call,
            contract_functions,
            external_calls,
            all_contracts,
        )


def _process_functions(functions: Sequence[Function]) -> str:
    # TODO  add support for top level function

    contract_functions: Dict[Contract, Set[str]] = defaultdict(
        set
    )  # contract -> contract functions nodes
    contract_calls: Dict[Contract, Set[str]] = defaultdict(set)  # contract -> contract calls edges

    solidity_functions: Set[str] = set()  # solidity function nodes
    solidity_calls: Set[str] = set()  # solidity calls edges
    external_calls: Set[str] = set()  # external calls edges

    all_contracts = set()

    for function in functions:
        if isinstance(function, FunctionContract):
            all_contracts.add(function.contract_declarer)
    for function in functions:
        if isinstance(function, FunctionContract):
            _process_function(
                function.contract_declarer,
                function,
                contract_functions,
                contract_calls,
                solidity_functions,
                solidity_calls,
                external_calls,
                all_contracts,
            )

    render_internal_calls = ""
    for contract in all_contracts:
        render_internal_calls += _render_internal_calls(
            contract, contract_functions, contract_calls
        )

    render_solidity_calls = _render_solidity_calls(solidity_functions, solidity_calls)

    render_external_calls = _render_external_calls(external_calls)

    return render_internal_calls + render_solidity_calls + render_external_calls


class PrinterCallGraphV2(AbstractPrinter):
    ARGUMENT = "call-graph"
    HELP = "Export the call-graph of the contracts to a dot file"

    WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#call-graph"

    def output(self, filename: str) -> Output:
        """
        Output the graph in filename
        Args:
            filename(string)
        """

        all_contracts_filename = ""
        if not filename.endswith(".dot"):
            if filename in ("", "."):
                filename = ""
            else:
                filename += "."
            all_contracts_filename = f"{filename}all_contracts.call-graph.dot"

        if filename == ".dot":
            all_contracts_filename = "all_contracts.dot"

        info = ""
        results = []
        with open(all_contracts_filename, "w", encoding="utf8") as f:
            info += f"Call Graph: {all_contracts_filename}\n"

            # Avoid duplicate functions due to different compilation unit
            all_functionss = [
                compilation_unit.functions for compilation_unit in self.slither.compilation_units
            ]
            all_functions = [item for sublist in all_functionss for item in sublist]
            all_functions_as_dict = {
                function.canonical_name: function for function in all_functions
            }
            content = "\n".join(
                ["strict digraph {"]
                + [_process_functions(list(all_functions_as_dict.values()))]
                + ["}"]
            )
            f.write(content)
            results.append((all_contracts_filename, content))

        for derived_contract in self.slither.contracts_derived:
            derived_output_filename = f"{filename}{derived_contract.name}.call-graph.dot"
            with open(derived_output_filename, "w", encoding="utf8") as f:
                info += f"Call Graph: {derived_output_filename}\n"
                content = "\n".join(
                    ["strict digraph {"] + [_process_functions(derived_contract.functions)] + ["}"]
                )
                f.write(content)
                results.append((derived_output_filename, content))

        self.info(info)
        res = self.generate_output(info)
        for filename_result, content in results:
            res.add_file(filename_result, content)

        return res

    def get_call_graph_content(self) -> Dict[str, str]:
        """
        Generate the call graph and return the content as a dictionary.
        Returns:
            dict: A mapping of contract names to their DOT string representations.
        """
        results = {}

        # Avoid duplicate functions due to different compilation unit
        all_functionss = [
            compilation_unit.functions for compilation_unit in self.slither.compilation_units
        ]
        all_functions = [item for sublist in all_functionss for item in sublist]
        all_functions_as_dict = {
            function.canonical_name: function for function in all_functions
        }
        content = "\n".join(
            ["strict digraph {"]
            + [_process_functions(list(all_functions_as_dict.values()))]
            + ["}"]
        )
        results["all_contracts"] = content

        for derived_contract in self.slither.contracts_derived:
            content = "\n".join(
                ["strict digraph {"] + [_process_functions(derived_contract.functions)] + ["}"]
            )
            results[derived_contract.name] = content

        return results

================
File: static_analysis/parse_contract.py
================
from slither import Slither
from slither.core.declarations.function import Function
from slither.core.declarations.contract import Contract
from slither.printers.abstract_printer import AbstractPrinter
from .slither_detectors import DETECTORS
from .call_graph_printer import PrinterCallGraphV2
from typing import Dict, List

def analyze_contract(filepath: str):
    """
    Analyzes a Solidity contract using Slither and returns:
    1. A list of function details (name, visibility, parameters, returns, etc.)
    2. A call graph mapping each function to the functions it calls
    """

    # Initialize Slither on the given file. This parses and compiles the contract.
    slither = Slither(filepath)
    printer = PrinterCallGraphV2(slither, None)
    # for detector_class in all_detectors.DETECTORS:
    for detector_class in DETECTORS:
        slither.register_detector(detector_class)
    detectors_results = slither.run_detectors()
    cfg_data = printer.get_call_graph_content()
    all_function_details = []
    call_graph = cfg_data

    # Iterate over each contract in the source
    for contract in slither.contracts:
        contract_name = contract.name

        # Iterate over each function in the contract
        for func in contract.functions:
            # Extract basic function info
            func_name = func.name
            visibility = str(func.visibility)  # e.g. 'public', 'external', ...
            parameters = [(str(p.type), p.name) for p in func.parameters]
            returns = [(str(r.type), r.name) for r in func.returns]

            # Lines of code (start_line, end_line). Not all functions have source mappings, handle None carefully.
            # source_mapping is typically a Slither object with multiple fields.
            start_line = func.source_mapping.start if func.source_mapping else None
            end_line = func.source_mapping.end if func.source_mapping else None

            # Prepare the function detail dict
            func_detail = {
                "contract": contract_name,
                "function": func_name,
                "visibility": visibility,
                "parameters": parameters,
                "returns": returns,
                "start_line": start_line,
                "end_line": end_line
            }
            all_function_details.append(func_detail)


    return all_function_details, call_graph, detectors_results

if __name__ == "__main__":
    # Example usage:
    filepath = "/Users/advait/Desktop/NTU/fyp-fr/static_analysis/test_contracts/code.sol"  # Adjust path to your .sol file
    function_details, cg, detector_results = analyze_contract(filepath)

    # Print function details
    print("==== Function Details ====")
    for f in function_details:
        print(f"Contract: {f['contract']}")
        print(f"Function: {f['function']}")
        print(f"Visibility: {f['visibility']}")
        print(f"Parameters: {f['parameters']}")
        print(f"Returns: {f['returns']}")
        print(f"Lines: {f['start_line']} - {f['end_line']}")
        print()

    # Print call graph
    # Returns the Call Graph formatted for DOT files
    print("==== Call Graph ====")
    print(cg['all_contracts'])

================
File: static_analysis/slither_detectors.py
================
# pylint: disable=unused-import,relative-beyond-top-level
from slither.detectors.examples.backdoor import Backdoor
from slither.detectors.variables.uninitialized_state_variables import UninitializedStateVarsDetection
from slither.detectors.variables.uninitialized_storage_variables import UninitializedStorageVars
from slither.detectors.variables.uninitialized_local_variables import UninitializedLocalVars
from slither.detectors.variables.var_read_using_this import VarReadUsingThis
from slither.detectors.attributes.constant_pragma import ConstantPragma
from slither.detectors.attributes.incorrect_solc import IncorrectSolc
from slither.detectors.attributes.locked_ether import LockedEther
from slither.detectors.functions.arbitrary_send_eth import ArbitrarySendEth
from slither.detectors.erc.erc20.arbitrary_send_erc20_no_permit import ArbitrarySendErc20NoPermit
from slither.detectors.erc.erc20.arbitrary_send_erc20_permit import ArbitrarySendErc20Permit
from slither.detectors.functions.suicidal import Suicidal

# from .functions.complex_function import ComplexFunction
from slither.detectors.reentrancy.reentrancy_benign import ReentrancyBenign
from slither.detectors.reentrancy.reentrancy_read_before_write import ReentrancyReadBeforeWritten
from slither.detectors.reentrancy.reentrancy_eth import ReentrancyEth
from slither.detectors.reentrancy.reentrancy_no_gas import ReentrancyNoGas
from slither.detectors.reentrancy.reentrancy_events import ReentrancyEvent
from slither.detectors.variables.unused_state_variables import UnusedStateVars
from slither.detectors.variables.could_be_constant import CouldBeConstant
from slither.detectors.variables.could_be_immutable import CouldBeImmutable
from slither.detectors.statements.tx_origin import TxOrigin
from slither.detectors.statements.assembly import Assembly
from slither.detectors.operations.low_level_calls import LowLevelCalls
from slither.detectors.operations.unused_return_values import UnusedReturnValues
from slither.detectors.operations.unchecked_transfer import UncheckedTransfer
from slither.detectors.naming_convention.naming_convention import NamingConvention
from slither.detectors.functions.external_function import ExternalFunction
from slither.detectors.statements.controlled_delegatecall import ControlledDelegateCall
from slither.detectors.attributes.const_functions_asm import ConstantFunctionsAsm
from slither.detectors.attributes.const_functions_state import ConstantFunctionsState
from slither.detectors.shadowing.abstract import ShadowingAbstractDetection
from slither.detectors.shadowing.state import StateShadowing
from slither.detectors.shadowing.local import LocalShadowing
from slither.detectors.shadowing.builtin_symbols import BuiltinSymbolShadowing
from slither.detectors.operations.block_timestamp import Timestamp
from slither.detectors.statements.calls_in_loop import MultipleCallsInLoop
from slither.detectors.statements.incorrect_strict_equality import IncorrectStrictEquality
from slither.detectors.erc.erc20.incorrect_erc20_interface import IncorrectERC20InterfaceDetection
from slither.detectors.erc.incorrect_erc721_interface import IncorrectERC721InterfaceDetection
from slither.detectors.erc.unindexed_event_parameters import UnindexedERC20EventParameters
from slither.detectors.statements.deprecated_calls import DeprecatedStandards
from slither.detectors.source.rtlo import RightToLeftOverride
from slither.detectors.statements.too_many_digits import TooManyDigits
from slither.detectors.operations.unchecked_low_level_return_values import UncheckedLowLevel
from slither.detectors.operations.unchecked_send_return_value import UncheckedSend
from slither.detectors.operations.void_constructor import VoidConstructor
from slither.detectors.statements.type_based_tautology import TypeBasedTautology
from slither.detectors.statements.boolean_constant_equality import BooleanEquality
from slither.detectors.statements.boolean_constant_misuse import BooleanConstantMisuse
from slither.detectors.statements.divide_before_multiply import DivideBeforeMultiply
from slither.detectors.statements.unprotected_upgradeable import UnprotectedUpgradeable
from slither.detectors.slither.name_reused import NameReused

from slither.detectors.functions.unimplemented import UnimplementedFunctionDetection
from slither.detectors.statements.mapping_deletion import MappingDeletionDetection
from slither.detectors.statements.array_length_assignment import ArrayLengthAssignment
from slither.detectors.variables.function_init_state_variables import FunctionInitializedState
from slither.detectors.statements.redundant_statements import RedundantStatements
from slither.detectors.operations.bad_prng import BadPRNG
from slither.detectors.statements.costly_operations_in_loop import CostlyOperationsInLoop
from slither.detectors.statements.assert_state_change import AssertStateChange
from slither.detectors.attributes.unimplemented_interface import MissingInheritance
from slither.detectors.assembly.shift_parameter_mixup import ShiftParameterMixup
from slither.detectors.compiler_bugs.storage_signed_integer_array import StorageSignedIntegerArray
from slither.detectors.compiler_bugs.uninitialized_function_ptr_in_constructor import (
    UninitializedFunctionPtrsConstructor,
)
from slither.detectors.compiler_bugs.storage_ABIEncoderV2_array import ABIEncoderV2Array
from slither.detectors.compiler_bugs.array_by_reference import ArrayByReference
from slither.detectors.compiler_bugs.enum_conversion import EnumConversion
from slither.detectors.compiler_bugs.multiple_constructor_schemes import MultipleConstructorSchemes
from slither.detectors.compiler_bugs.public_mapping_nested import PublicMappingNested
from slither.detectors.compiler_bugs.reused_base_constructor import ReusedBaseConstructor
from slither.detectors.operations.missing_events_access_control import MissingEventsAccessControl
from slither.detectors.operations.missing_events_arithmetic import MissingEventsArithmetic
from slither.detectors.functions.modifier import ModifierDefaultDetection
from slither.detectors.variables.predeclaration_usage_local import PredeclarationUsageLocal
from slither.detectors.statements.unary import IncorrectUnaryExpressionDetection
from slither.detectors.operations.missing_zero_address_validation import MissingZeroAddressValidation
from slither.detectors.functions.dead_code import DeadCode
from slither.detectors.statements.write_after_write import WriteAfterWrite
from slither.detectors.statements.msg_value_in_loop import MsgValueInLoop
from slither.detectors.statements.delegatecall_in_loop import DelegatecallInLoop
from slither.detectors.functions.protected_variable import ProtectedVariables
from slither.detectors.functions.permit_domain_signature_collision import DomainSeparatorCollision
from slither.detectors.functions.codex import Codex
from slither.detectors.functions.cyclomatic_complexity import CyclomaticComplexity
from slither.detectors.operations.cache_array_length import CacheArrayLength
from slither.detectors.statements.incorrect_using_for import IncorrectUsingFor
from slither.detectors.operations.encode_packed import EncodePackedCollision
from slither.detectors.assembly.incorrect_return import IncorrectReturn
from slither.detectors.assembly.return_instead_of_leave import ReturnInsteadOfLeave
from slither.detectors.operations.incorrect_exp import IncorrectOperatorExponentiation
from slither.detectors.statements.tautological_compare import TautologicalCompare
from slither.detectors.statements.return_bomb import ReturnBomb
from slither.detectors.functions.out_of_order_retryable import OutOfOrderRetryable

# from .statements.unused_import import UnusedImport

DETECTORS = [
    Backdoor, UninitializedStateVarsDetection, UninitializedStorageVars, UninitializedLocalVars,
    VarReadUsingThis, ConstantPragma, IncorrectSolc, LockedEther, ArbitrarySendEth,
    ArbitrarySendErc20NoPermit, ArbitrarySendErc20Permit, Suicidal, ReentrancyBenign,
    ReentrancyReadBeforeWritten, ReentrancyEth, ReentrancyNoGas, ReentrancyEvent, UnusedStateVars,
    CouldBeConstant, CouldBeImmutable, TxOrigin, Assembly, LowLevelCalls, UnusedReturnValues,
    UncheckedTransfer, NamingConvention, ExternalFunction, ControlledDelegateCall,
    ConstantFunctionsAsm, ConstantFunctionsState, ShadowingAbstractDetection, StateShadowing,
    LocalShadowing, BuiltinSymbolShadowing, Timestamp, MultipleCallsInLoop, IncorrectStrictEquality,
    IncorrectERC20InterfaceDetection, IncorrectERC721InterfaceDetection,
    UnindexedERC20EventParameters, DeprecatedStandards, RightToLeftOverride, TooManyDigits,
    UncheckedLowLevel, UncheckedSend, VoidConstructor, TypeBasedTautology, BooleanEquality,
    BooleanConstantMisuse, DivideBeforeMultiply, UnprotectedUpgradeable, NameReused,
    UnimplementedFunctionDetection, MappingDeletionDetection, ArrayLengthAssignment,
    FunctionInitializedState, RedundantStatements, BadPRNG, CostlyOperationsInLoop,
    AssertStateChange, MissingInheritance, ShiftParameterMixup, StorageSignedIntegerArray,
    UninitializedFunctionPtrsConstructor, ABIEncoderV2Array, ArrayByReference, EnumConversion,
    MultipleConstructorSchemes, PublicMappingNested, ReusedBaseConstructor,
    MissingEventsAccessControl, MissingEventsArithmetic, ModifierDefaultDetection,
    PredeclarationUsageLocal, IncorrectUnaryExpressionDetection, MissingZeroAddressValidation,
    DeadCode, WriteAfterWrite, MsgValueInLoop, DelegatecallInLoop, ProtectedVariables,
    DomainSeparatorCollision, Codex, CyclomaticComplexity, CacheArrayLength, IncorrectUsingFor,
    EncodePackedCollision, IncorrectReturn, ReturnInsteadOfLeave, IncorrectOperatorExponentiation,
    TautologicalCompare, ReturnBomb, OutOfOrderRetryable
]

================
File: .gitignore
================
# Virtual Environment
.venv

# Environment variables
.env

# Pycache
static_analysis/scripts/__pycache__

================
File: main.py
================
# main.py
import os
from static_analysis.parse_contract import analyze_contract
from llm_agents.agent_coordinator import AgentCoordinator
from rag.vectorstore import VulnerabilityKB

def main():
    # Ensure OpenAI API key is set
    if not os.getenv("OPENAI_API_KEY"):
        raise ValueError("Please set OPENAI_API_KEY environment variable")

    # 1. Initialize knowledge base
    kb = VulnerabilityKB()

    # 2. Analyze contract
    filepath = "static_analysis/test_contracts/code.sol"
    function_details, call_graph, detector_results = analyze_contract(filepath)

    contract_info = {
        "function_details": function_details,
        "call_graph": call_graph
    }

    # Print the Stage
    print("==== STATIC ANALYSIS ====")
    print("Contract Info:")
    print(call_graph['all_contracts'])
    print("Function Details:")

    # Loop through the list and print each function detail
    for f in function_details:
        print(f"\nContract: {f['contract']}")
        print(f"Function: {f['function']}")
        print(f"Visibility: {f['visibility']}")
        print(f"Parameters: {f['parameters']}")
        print(f"Returns: {f['returns']}")
        print(f"Lines: {f['start_line']} - {f['end_line']}\n")


    # 3. Initialize coordinator with knowledge base
    coordinator = AgentCoordinator(kb)

    # 4. Get results
    results = coordinator.analyze_contract(contract_info)

    print("Analysis Results:", results)

if __name__ == "__main__":
    main()

================
File: requirements.txt
================
tiktoken
langchain
langchain-community
openai
slither-analyzer
faiss-cpu
